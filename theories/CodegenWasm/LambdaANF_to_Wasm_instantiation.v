Set Printing Compact Contexts.

(* This file contains the proofs related to instantiation, it has the following sections:

  * INSTANTIATION: the modules generated by CertiCoq-Wasm instantiate
  * POST_INSTANTIATION: post-instantiation intitializes table correctly
*)

From Coq Require Import
  Logic.Decidable Lists.ListDec
  Relations.Relations Relations.Relation_Operators
  Lia Nnat Permutation.

From compcert Require Import
  Coqlib.

From MetaCoq Require Import EWcbvEvalNamed. (* for string_of_nat_inj *)

From CertiCoq Require Import
  LambdaANF.cps_util
  LambdaANF.List_util
  LambdaANF.Ensembles_util LambdaANF.identifiers
  LambdaANF.shrink_cps_corresp
  Libraries.maps_util
  CodegenWasm.LambdaANF_to_Wasm
  CodegenWasm.LambdaANF_to_Wasm_utils
  CodegenWasm.LambdaANF_to_Wasm_correct
  CodegenWasm.LambdaANF_to_Wasm_primitives
  CodegenWasm.LambdaANF_to_Wasm_typing
  CodegenWasm.LambdaANF_to_Wasm_restrictions.

From Wasm Require Import
  datatypes operations
  instantiation_spec instantiation_func instantiation_properties
  properties.

From Coq Require Import List.

Import ssreflect eqtype ssrbool.
Import LambdaANF.toplevel LambdaANF.cps compM.
Import ExtLib.Structures.Monad MonadNotation.
Import bytestring MCString.
Import ListNotations.
Import seq.

Section INSTANTIATION.
Variable cenv   : ctor_env.
Variable funenv : fun_env.
Variable nenv   : name_env.
Variable penv   : prim_env.

Context `{ho : host}.
Variable hfn : host_function.

Definition initial_store :=
{| s_funcs   := nil
 ; s_tables  := nil
 ; s_mems    := nil
 ; s_datas   := nil
 ; s_elems   := nil
 ; s_globals := nil
 |}.

Lemma inductive_eq_dec : forall e,
  {exists fds e', e = Efun fds e'} + {~exists fds e', e = Efun fds e'}.
Proof.
  destruct e; eauto.
  all: right; now intros [? [? Hcontra]].
Qed.

Fixpoint elem_vals (funs : nat) (startidx : nat) : seq (seq value_ref) :=
  match funs with
  | 0 => []
  | S funs' => [:: VAL_ref_func (N.of_nat startidx)] :: elem_vals funs' (S startidx)
  end.

Lemma elem_vals_length : forall num_funs idx,
  length (elem_vals num_funs idx) = num_funs.
Proof.
  induction num_funs; cbn; intros; auto.
Qed.

Lemma elem_vals_nth_error : forall num_funs idx n,
  n < num_funs ->
  nth_error (elem_vals num_funs idx) n = Some [:: VAL_ref_func (N.of_nat (idx + n))].
Proof.
  induction num_funs; intros; try lia.
  destruct n.
  - cbn. do 3 f_equal. lia.
  - cbn. replace (idx + S n) with (S idx + n) by lia.
    rewrite IHnum_funs. reflexivity. lia.
Qed.

Lemma list_function_types_valid :
  Forall (fun ft : function_type => functype_valid ft)
         (list_function_types (Z.to_nat max_function_args)).
Proof.
  by apply Forall_forall.
Qed.

Lemma table_element_mapping_length : forall len i,
  Datatypes.length (table_element_mapping len i) = len.
Proof.
  by induction len; intros; cbn; auto.
Qed.

Lemma table_element_mapping_nth_error : forall num_funs idx x,
  x < num_funs ->
  nth_error (table_element_mapping num_funs idx) x =
    Some {| modelem_type := T_funcref
          ; modelem_init := [:: [:: BI_ref_func (N.of_nat (idx + x))]]
          ; modelem_mode := ME_active 0%N [:: BI_const_num (nat_to_value (idx + x))]
          |}.
Proof.
  induction num_funs; intros; cbn.
  - intros. lia.
  - destruct x. cbn. eauto. repeat f_equal; lia. cbn.
    replace (idx + S x) with (S idx + x) by lia.
    apply IHnum_funs. lia.
Qed.

Fixpoint funcidcs (funs : nat) (startidx : funcidx) : list funcidx :=
  match funs with
  | 0 => []
  | S funs' => startidx :: funcidcs funs' (N.succ startidx)
  end.

Lemma funcidcs_length : forall n m,
  length (funcidcs n m) = n.
Proof.
  induction n; intros; cbn; eauto.
Qed.

Lemma nth_error_funcidcs {A} : forall (l : list A) len n idx,
  n < len ->
  nth_error (funcidcs len idx) n = Some (idx + N.of_nat n)%N.
Proof.
  induction len; intros; cbn in H. lia.
  destruct n; cbn. f_equal. lia.
  assert (n < len) by lia.
  replace (idx + N.pos (Pos.of_succ_nat n))%N with (N.succ idx + N.of_nat n)%N by lia.
  now apply IHlen.
Qed.

Lemma elems_instantiate : forall hs sr fr num_funs,
  fr.(f_inst).(inst_funcs) = [seq N.of_nat i | i <- iota 0 num_funs] ->
  Forall2
  (fun (e1 : module_element) (rs : seq value_ref) =>
   Forall2
     (fun (bes : seq basic_instruction) (r : value_ref) =>
      reduce_trans
        (hs, sr, fr, to_e_list bes)
        (hs, sr, fr, [:: vref_to_e r])) (modelem_init e1) rs)
  (table_element_mapping num_funs 0)
  (elem_vals num_funs 0).
Proof.
  intros ?????.
  apply Forall2_spec.
  - by rewrite table_element_mapping_length elem_vals_length.
  - intros ??? Hnth1 Hnth2.
    assert (n < num_funs). {
      apply nth_error_Some_length in Hnth1.
      by rewrite table_element_mapping_length in Hnth1. }
    rewrite table_element_mapping_nth_error in Hnth1=>//. injection Hnth1 as <-.
    cbn in H. cbn.
    rewrite elem_vals_nth_error in Hnth2; auto.
    injection Hnth2 as <-.
    apply Forall2_spec=>//.
    intros.
    destruct n0; last by destruct n0.
    injection H1 as <-. injection H2 as <-.
    apply rt_step. apply r_ref_func.
    rewrite H.
    unfold lookup_N. rewrite nth_error_map.
    rewrite iota_lookup. unfold ssrnat.addn. cbn. f_equal. lia.
    apply /ssrnat.leP. lia.
Qed.

Lemma funcidx_in_table_element_mapping : forall num_funs n idx,
  n < num_funs ->
  In (N.of_nat (idx + n))
  (concat
     (List.map module_elem_get_funcidx
        (table_element_mapping num_funs idx))).
Proof.
  induction num_funs; intros; first lia.
  destruct n. left. lia. cbn. right.
  replace (idx + S n) with (S idx + n) by lia.
  apply IHnum_funs. lia.
Qed.

Lemma length_list_function_types : forall n,
  length (list_function_types n) = S n.
Proof.
  induction n; cbn; auto.
  now rewrite length_map.
Qed.

Lemma nth_list_function_types : forall m n def,
  m <= n ->
  List.nth m (list_function_types n) def =
  Tf (List.repeat (T_num T_i32) m) [].
Proof.
  induction m; intros; try lia.
  - destruct n; auto; lia.
  - have Hlen := length_list_function_types n.
    destruct n. lia. assert (Hlt: m <= n) by lia.
    remember (fun t : function_type =>
      match t with
      | Tf args rt => Tf (T_num T_i32 :: args)%SEQ rt
      end) as f.
    have Hindep := nth_indep _ _ (f def).
    rewrite Hindep; try lia.
       cbn. subst f. rewrite map_nth.
    rewrite IHm; auto.
Qed.

Lemma module_typing_module_elem_typing : forall fns c t,
  (* types of grow_mem, main, fns *)
  tc_funcs c = [:: Tf [::] [::] &
               [seq Tf (repeat (T_num T_i32) (N.to_nat (type f))) [::] | f <- fns]] ->
  lookup_N (tc_tables c) 0%N = Some t ->
  tt_elem_type t = T_funcref ->
  (forall n, lookup_N (tc_funcs c) (N.of_nat n) <> None -> In (N.of_nat n) (tc_refs c)) ->
  Forall2 (module_elem_typing c) (table_element_mapping (Datatypes.length fns + num_custom_funs) 0)
                                 (repeat T_funcref (length fns + num_custom_funs)).
Proof.
  intros ??? Hft Htab1 Htab2 Hrefs. unfold num_custom_funs.
  apply Forall2_spec. by rewrite table_element_mapping_length repeat_length.
  intros ??? Hnth1 Hnth2.
  assert (n < length fns + num_custom_funs). {
    apply nth_error_Some_length in Hnth1.
    by rewrite table_element_mapping_length in Hnth1.
  }
  rewrite table_element_mapping_nth_error in Hnth1=>//. injection Hnth1 as <-.
  rewrite nth_error_repeat in Hnth2=>//. injection Hnth2 as <-.
  do 2 split=>//.
  - apply Forall_forall.
    intros. cbn in H0. destruct H0=>//. subst x.
    split=>//.
    assert (length (tc_funcs c) = num_custom_funs + length fns).
    { rewrite Hft. cbn. now rewrite length_map. }
    assert (exists x, lookup_N (tc_funcs c) (N.of_nat n) = Some x) as [x Hx].
    { apply notNone_Some. apply nth_error_Some. lia. }
    eapply bet_ref_func; eauto. now apply Hrefs.
  - cbn. exists t. cbn in Htab1. rewrite Htab1.
    destruct t. cbn in Htab2.
    repeat split=>//. apply bet_const_num.
Qed.

Lemma add_funcs_effect : forall s' s'' l l1 l2 mi,
  fold_left (fun '(s, ys) (x : module_func) =>
               (add_func s (gen_func_instance x mi),
                N.of_nat (Datatypes.length (s_funcs s)) :: ys))
            l (s', l1) = (s'', l2) ->
  (s_datas s' = s_datas s'') /\
  (s_elems s' = s_elems s'') /\
  (s_globals s' = s_globals s'') /\
  (s_mems s' = s_mems s'') /\
  (s_tables s' = s_tables s'') /\
  (s_funcs s'' = (s_funcs s') ++
  (map (fun a => gen_func_instance a mi) l ))%list /\
  l2 = List.app (List.rev (funcidcs (length l) (N.of_nat (length (s_funcs s'))))) l1.
Proof.
  intros. generalize dependent l1. revert s' s'' l2.
  induction l; intros.
  - inv H. cbn. rewrite app_nil_r. tauto.
  - cbn in H. apply IHl in H.
    destruct H as [H1 [H2 [H3 [H4 [H5 [H6 H7]]]]]]. subst l2. rewrite -H1 -H2 -H3 -H4 -H5 H6.
    rewrite -app_assoc.
    repeat split; auto.
    replace (N.of_nat (Datatypes.length (s_funcs s')) :: l1) with
            ([:: N.of_nat (Datatypes.length (s_funcs s'))]  ++ l1) by reflexivity.
    rewrite length_app Nat.add_comm. cbn.
    rewrite -app_assoc. cbn.
    do 3 f_equal. lia.
Qed.

Lemma translate_fvar_fname_mapping_aux : forall fds e f i n env,
  (forall x j, env ! x = Some j -> j < N.of_nat (numOf_fundefs fds) + n)%N ->
  (create_var_mapping n (collect_function_vars (Efun fds e)) env) ! f = Some i ->
  (i < N.of_nat (numOf_fundefs fds) + n)%N.
Proof.
  induction fds; intros.
  - remember (numOf_fundefs (Fcons v f l e fds)) as len.
    cbn in Heqlen. destruct len=>//.
    cbn in H0. rename H0 into Hf.
    destruct (var_dec f0 v).
    + (* f0=v *)
      subst f0. rewrite M.gss in Hf. inv Hf. lia.
    + (* f0<>v *)
      cbn in Hf. rewrite M.gso in Hf; auto.
      apply IHfds in Hf. injection Heqlen as ->. cbn. destruct n; try lia.
      assumption. intros.
      apply H in H0. cbn in H0. destruct n; lia.
  - inv H0. now eapply H.
Qed.

Lemma translate_fvar_fname_mapping : forall e f errMsg i,
  translate_var nenv (create_fname_mapping e) f errMsg = Ret i ->
  match e with Efun fds _ => N.to_nat i < numOf_fundefs fds + num_custom_funs | _ => True end.
Proof.
  intros. unfold create_fname_mapping, translate_var in H.
  destruct ((create_var_mapping (N.of_nat num_custom_funs) (collect_function_vars e)
         (M.empty _)) ! f) eqn:Hf; rewrite Hf in H; inv H.
  destruct e; auto. rename f0 into fds.
  apply translate_fvar_fname_mapping_aux in Hf. lia.
  intros. inv H.
Qed.

Lemma translate_functions_exists_original_fun : forall fds fds'' fns wasmFun e eAny fenv,
  NoDup (collect_function_vars (Efun fds e)) ->
  translate_functions nenv cenv fenv penv fds = Ret fns ->
  fenv = create_fname_mapping (Efun fds'' eAny) ->
  In wasmFun fns ->
  exists f t ys e, find_def f fds = Some (t, ys, e) /\ (type wasmFun) = N.of_nat (length ys) /\ @repr_funvar fenv nenv f (wasmFun.(fidx)).
Proof.
  induction fds; intros fds'' fns wasmFun e' eAny fenv Hnodup Htrans Hfenv Hin.
  2: { inv Htrans. inv Hin. }
  simpl in Htrans.
  destruct (translate_function nenv cenv _ penv v l e) eqn:transF. inv Htrans.
  cbn. destruct (translate_functions _ _ _ ) eqn:Htra; inv Htrans. destruct Hin.
  - (* wasmFun is first fn *) subst w.
    exists v, f, l, e. destruct (M.elt_eq); last contradiction.
    split; auto.
    unfold translate_function in transF.
    destruct (translate_var _ _ _ _) eqn:HtransFvar. inv transF.
    destruct (translate_body _ _ _ _) eqn:HtransE. inv transF.
    inv transF. cbn.  split=>//. now econstructor.
  - (* wasmFun is not first fn *)
    eapply IHfds in H; eauto. 2: { now inv Hnodup. }
    destruct H as [f' [t' [ys' [e'' [Hfdef Hty]]]]].
    exists f', t', ys', e''. split; auto. rewrite -Hfdef.
    destruct (M.elt_eq f' v); auto. subst v. exfalso.
    inv Hnodup. apply H1. clear H2. cbn.
    now eapply find_def_in_collect_function_vars.
Unshelve. all: assumption.
Qed.

Lemma translate_functions_length {fenv} : forall fds fns,
  translate_functions nenv cenv fenv penv fds = Ret fns ->
  numOf_fundefs fds = length fns.
Proof.
  induction fds; intros. 2: { now inv H. }
  simpl in H.
  destruct (translate_function nenv cenv fenv penv v l e). inv H.
  destruct (translate_functions _ _ _ _ fds). inv H.
  destruct fns; inv H. cbn. now rewrite -IHfds.
Qed.

Lemma translate_functions_fenv : forall fds fns fenv e i x,
  map_injective fenv ->
  translate_functions nenv cenv fenv penv fds = Ret fns ->
  i < numOf_fundefs fds ->
  nth_error (collect_function_vars (Efun fds e)) i = Some x ->
  option_map (fun f => fidx f) (nth_error fns i) = fenv ! x.
Proof.
  induction fds; intros ????? Hinj Hfns Hlt Hnth. 2:{ cbn in Hlt. lia. }
  destruct fns; first by apply translate_functions_length in Hfns. simpl in Hfns.
  destruct (translate_function _ _ _ _ _ _) eqn:HtransF. inv Hfns.
  destruct (translate_functions _ _ _ _) eqn:Hfuns; inv Hfns.
  destruct i.
  - (* i=0 *)
    cbn. inv Hnth.
    unfold translate_function in HtransF.
    destruct (translate_var _ _ _ _) eqn:HtransV. inv HtransF.
    destruct (translate_body _ _ _ _ _). inv HtransF. inv HtransF.
    unfold translate_var in HtransV.
    destruct (fenv ! x) eqn:HtransV'; rewrite HtransV' in HtransV=>//=.
    by injection HtransV as ->.
  - (* i=Si' *)
    cbn in Hlt. cbn.
    eapply IHfds; eauto. lia.
Unshelve. assumption.
Qed.

Lemma translate_functions_idx_bounds : forall fds fns fenv min max,
  (forall f f', fenv ! f = Some f' -> min <= f' < max)%N ->
  translate_functions nenv cenv fenv penv fds = Ret fns ->
  forall idx, In idx (map fidx fns) -> (min <= idx < max)%N.
Proof.
  induction fds; intros ???? Hbounds Hfns ? Hin; last by inv Hfns.
  destruct fns. inv Hin. simpl in Hfns.
  destruct (translate_function _ _ _ _ _ _) eqn:HtransF. inv Hfns.
  destruct (translate_functions _ _ _ _ fds) eqn:Hfix; inv Hfns.
  destruct Hin.
  - (* i=0 *)
    subst. unfold translate_function in HtransF.
    destruct (translate_var _ _ _ _) eqn:HtransV. inv HtransF.
    destruct (translate_body _ _ _ _ _). inv HtransF. inv HtransF.
    unfold translate_var in HtransV. cbn.
    destruct (fenv ! v) eqn:HtransV'; rewrite HtransV' in HtransV; inv HtransV.
    now apply Hbounds in HtransV'.
  - (* i=Si' *)
    by eapply IHfds; eauto.
Qed.

Lemma translate_functions_increasing_fids : forall fds fns fenv eAny1 eAny2,
  fenv = create_fname_mapping (Efun fds eAny1) ->
  map_injective fenv ->
  NoDup (collect_function_vars (Efun fds eAny2)) ->
  translate_functions nenv cenv fenv penv fds = Ret fns ->
  (forall i j i' j', i > j -> nth_error (map (fun f => fidx f) fns) i = Some i' ->
                              nth_error (map (fun f => fidx f) fns) j = Some j' -> (i' > j')%N).
Proof.
  intros ????? Hfds Hinj Hnodup HtransFns ? ? ? ? Hgt Hi Hj.
  rewrite nth_error_map in Hi. rewrite nth_error_map in Hj.
  destruct (nth_error fns i) eqn:Hio. 2: inv Hi. cbn in Hi. inv Hi.
  destruct (nth_error fns j) eqn:Hjo. 2: inv Hj. cbn in Hj. inv Hj.

  have Hlen := translate_functions_length _ _ HtransFns. symmetry in Hlen.

  assert (Hilen: i < numOf_fundefs fds). { rewrite -Hlen. now apply nth_error_Some. }
  have Hilen' := Hilen.  rewrite <- (collect_function_vars_length _ eAny1) in Hilen'.
  apply nth_error_Some in Hilen'. apply notNone_Some in Hilen'. destruct Hilen' as [v Hiv].
  have Hi' := translate_functions_fenv _ _ _ _ _ _ Hinj HtransFns Hilen Hiv.
  rewrite Hio in Hi'. cbn in Hi'.

  assert (Hjlen: j < numOf_fundefs fds). { rewrite -Hlen. now apply nth_error_Some. }
  have Hjlen' := Hjlen. rewrite <- (collect_function_vars_length _ eAny1) in Hjlen'.
  apply nth_error_Some in Hjlen'. apply notNone_Some in Hjlen'. destruct Hjlen' as [v' Hjv'].
  have Hj' := translate_functions_fenv _ _ _ _ _ _ Hinj HtransFns Hjlen Hjv'.

  rewrite Hjo in Hj'. cbn in Hj'.
  symmetry in Hj', Hi'.
  remember (fidx w) as i'. remember (fidx w0) as j'. clear Heqi' Heqj'.

  assert (Hi'': translate_var nenv (create_fname_mapping (Efun fds eAny1)) v ""%bs = Ret i'). {
    unfold translate_var. now rewrite Hi'. }
  assert (Hj'': translate_var nenv (create_fname_mapping (Efun fds eAny2)) v' ""%bs = Ret j'). {
    unfold translate_var. now rewrite Hj'. }
  unfold create_fname_mapping in Hi'.
  rewrite -(Nat2N.id i) in Hiv. rewrite -(Nat2N.id j) in Hjv'.
  rewrite (var_mapping_list_lt_length_nth_error_idx _ _ (N.of_nat num_custom_funs) _ _ _ Hiv) in Hi''; auto.
  rewrite (var_mapping_list_lt_length_nth_error_idx _ _ (N.of_nat num_custom_funs) _ _ _ Hjv') in Hj''; auto.
  remember (_ + N.of_nat i)%N as i''. injection Hi'' as ->.
  remember (_ + N.of_nat j)%N as j''. injection Hj'' as ->. lia.
Qed.

Lemma increasing_list_fact_trans : forall n l i i' i'n,
  (forall i j i' j', i > j -> nth_error l i = Some i' ->
                              nth_error l j = Some j' -> (i' > j')%N) ->
  nth_error l i = Some i' ->
  nth_error l (i + n) = Some i'n -> (i'n >= i' + N.of_nat n)%N.
Proof.
  induction n; intros. replace (i+0) with i in H1 by lia.
  assert (i' = i'n) by congruence. lia.

  assert (Hnext: S i < length l). {
    assert (nth_error l (i + S n) <> None) by congruence.
    apply nth_error_Some in H2. lia. }
  apply nth_error_Some in Hnext. apply notNone_Some in Hnext.
  destruct Hnext as [m Hm].
  replace (i + S n) with (S i + n) in H1 by lia.
  have IH := IHn _ _ _ _ _ Hm H1.
  assert (i'n >= m + N.of_nat n)%N. { apply IH. assumption. }

  have H' := H (S i) i _ _ _ Hm H0. lia.
Qed.

Lemma increasing_list_fact_id : forall l i i' n,
  (forall i j i' j', i > j -> nth_error l i = Some i' ->
                              nth_error l j = Some j' -> (i' > j')%N) ->
  (forall j j', nth_error l j = Some j' -> n <= N.to_nat j' < length l + n) ->
  nth_error l i = Some i' -> n+i = N.to_nat i'.
Proof.
  intros.
  assert (n + i >= N.to_nat i'). {
    assert (Hl: length l - 1 < length l). { destruct l. destruct i; inv H1. cbn. lia. }
    apply nth_error_Some in Hl. apply notNone_Some in Hl. destruct Hl as [v Hv].
    assert (i < length l). { now apply nth_error_Some. }
    replace (length l - 1) with (i + (length l - 1 - i)) in Hv by lia.
    have H' := increasing_list_fact_trans _ _ _ _ _ H H1 Hv.
    apply H0 in Hv. lia. }
  assert (n + i <= N.to_nat i'). {
    assert (exists v, nth_error l 0 = Some v). {
      apply notNone_Some. apply nth_error_Some. destruct l. destruct i; inv H1. cbn. lia. }
    destruct H3 as [v Hv].
    have H' := increasing_list_fact_trans _ _ _ _ _ H Hv H1.
    apply H0 in Hv. lia. }
  lia.
Qed.

Lemma fns_fidx_nth_error_fidx : forall fns func j,
  (forall (i j : nat) (i' j' : funcidx),
      i > j ->
      nth_error [seq fidx f | f <- fns] i = Some i' ->
      nth_error [seq fidx f | f <- fns] j = Some j' -> (i' > j')%N) ->
  (forall idx, In idx (map fidx fns) -> num_custom_funs <= N.to_nat idx < length fns + num_custom_funs) ->
  nth_error fns j = Some func ->
  nth_error fns (N.to_nat (fidx func - N.of_nat num_custom_funs)) = Some func.
Proof.
  intros. unfold num_custom_funs in *.
  assert (Hin: In func fns). { eapply nth_error_In. eassumption. }
  apply in_map with (f:=fidx) in Hin.
  apply H0 in Hin.
  destruct (N.to_nat (fidx func)) eqn:Hfi. lia. cbn.
  replace (N.to_nat (fidx func - _)) with n by lia.
  assert (Hlen: n < length fns) by lia.

  assert (Ho: option_map fidx (nth_error fns j) = option_map fidx (Some func)) by congruence.
  rewrite <- nth_error_map in Ho.

  assert (Hbounds: (forall j j',
      nth_error [seq fidx f | f <- fns] j = Some j' ->
      num_custom_funs <= N.to_nat j' < length [seq fidx f | f <- fns] + num_custom_funs)). {
    intros. apply nth_error_In in H2. apply H0 in H2.
    now rewrite length_map.
  }

  have H' := increasing_list_fact_id _ _ _ num_custom_funs H Hbounds Ho.
  unfold num_custom_funs in H'.

  assert (n=j) by lia. congruence.
Qed.

Lemma translate_functions_NoDup : forall fds fns fenv eAny1 eAny2,
  fenv = create_fname_mapping (Efun fds eAny1) ->
  map_injective fenv ->
  NoDup (collect_function_vars (Efun fds eAny2)) ->
  translate_functions nenv cenv fenv penv fds = Ret fns ->
  NoDup (map (fun f => fidx f) fns).
Proof.
  intros ????? -> Hinj Hnodup HtransFns.
  have H' := translate_functions_increasing_fids _ _ _ _ _ Logic.eq_refl Hinj Hnodup HtransFns.
  apply NoDup_nth_error. intros ? ? HiLen Heq.
  destruct (Nat.eq_dec i j); auto. exfalso.
  apply nth_error_Some in HiLen. apply notNone_Some in HiLen. destruct HiLen as [v Hv].
  rewrite Hv in Heq. symmetry in Heq.
  destruct (Nat.ltb_spec i j).
  (* i<j *)
  have Hcontra := H' _ _ _ _ _ Heq Hv. lia.
  (* i>j *)
  assert (Hgt: i>j) by lia.
  have Hcontra := H' _ _ _ _ Hgt Hv Heq. lia.
Qed.

Lemma translate_functions_type_bound {fenv} : forall fds fns fn eAny,
  NoDup (collect_function_vars (Efun fds eAny)) ->
  (forall f t ys e', find_def f fds = Some (t, ys, e') ->
             Z.of_nat (length ys) <= max_function_args /\
             expression_restricted cenv e')%Z ->
  translate_functions nenv cenv fenv penv fds = Ret fns ->
  In fn fns ->
  (type fn <= Z.to_N max_function_args)%N.
Proof.
  induction fds. 2:{ intros. by inv H1. }
  intros ??? Hnodup Hrestr Htrans Hin. cbn in Htrans.
  destruct (translate_var nenv fenv v _) eqn:Hvar=>//.
  destruct (translate_body _ _ _ _ _) eqn:Hbody=>//.
  destruct (translate_functions _ _ _ _ _) eqn:Hfns=>//. inv Htrans.
  have H' := Hrestr v f l e. cbn in H'.
  destruct (M.elt_eq v v)=>//. destruct H' as [H' _]=>//.
  unfold max_function_args in H'.
  destruct Hin as [Hin|Hin].
  - subst. cbn. lia.
  - eapply IHfds; eauto.
    + cbn in Hnodup. inv Hnodup. eassumption.
    + intros. eapply Hrestr with (f:=f0); eauto. cbn.
      destruct (M.elt_eq f0 v); eauto. exfalso.
      subst. inv Hnodup. apply H2. apply find_def_in_collect_function_vars; auto.
      congruence.
Unshelve. assumption.
Qed.

Lemma translate_functions_nth_error_idx : forall eAny1 eAny2 fds fns j func,
  NoDup (collect_function_vars (Efun fds eAny1)) ->
  translate_functions nenv cenv (create_fname_mapping (Efun fds eAny2)) penv fds = Ret fns ->
  nth_error fns j = Some func ->
  j = N.to_nat (fidx func) - num_custom_funs.
Proof.
  intros ?????? Hnodup Hfns Hin.
  assert (Hinj: map_injective (create_fname_mapping (Efun fds eAny1))). {
    by apply create_local_variable_mapping_injective.
  }
  have H'' := translate_functions_increasing_fids _ _ _ _ _ Logic.eq_refl Hinj Hnodup Hfns.
  assert (Hbounds: forall idx, In idx [seq fidx i | i <- fns] ->
             (N.of_nat num_custom_funs <= idx < N.of_nat (Datatypes.length fns + num_custom_funs))%N). {
    intros ? Hidx.
    have H' := translate_functions_idx_bounds _ _ _ _ _ _ Hfns _ Hidx. apply H'.
    intros ? ? Hf.
    split. { apply local_variable_mapping_gt_idx in Hf. lia. }
    assert (HtransF: translate_var nenv (create_fname_mapping (Efun fds eAny1)) f ""%bs = Ret f'). {
    unfold translate_var. now rewrite Hf. }
    apply var_mapping_list_lt_length' in HtransF.
    rewrite collect_function_vars_length in HtransF.
    erewrite <- translate_functions_length; eauto. lia.
  }
  assert (Hnth: nth_error fns (N.to_nat (fidx func - N.of_nat num_custom_funs)) = Some func). {
    eapply fns_fidx_nth_error_fidx; eauto. intros.
    apply Hbounds in H. lia. }
  rewrite -Hin in Hnth.
  have Hnodup' := translate_functions_NoDup _ _ _ _ _ Logic.eq_refl Hinj Hnodup Hfns.
  apply NoDup_map_inv in Hnodup'.
  eapply NoDup_nth_error; eauto.
  now apply nth_error_Some. rewrite -Hnth. f_equal. lia.
Qed.

Lemma translate_functions_find_def : forall fds f fns t ys e eAny fenv,
  NoDup (collect_function_vars (Efun fds eAny)) ->
  translate_functions nenv cenv fenv penv fds = Ret fns ->
  find_def f fds = Some (t, ys, e) ->
  (forall f t ys e, find_def f fds = Some (t, ys, e) -> correct_cenv_of_exp cenv e) ->
  exists idx e' locs func, repr_funvar fenv nenv f idx /\
    locs = repeat (T_num T_i32) (length (collect_local_variables e)) /\
    In func fns /\
    func.(fidx) = idx /\
    func.(type) = N.of_nat (length ys) /\
    func.(locals) = locs /\
    func.(body) = e' /\
    repr_expr_LambdaANF_Wasm cenv fenv nenv penv e 0 e'
     (lenv := create_local_variable_mapping (ys ++ collect_local_variables e)).
Proof.
  induction fds; intros ??????? Hnodup HtransFns HfDef HcorrCenv; last by inv HfDef.
  simpl in HtransFns.
  destruct (translate_function _ _ _ _ _ _) eqn:Hf. inv HtransFns.
  destruct (translate_functions _ _ _ _ fds) eqn:Hfns; inv HtransFns.
  cbn in HfDef. destruct (M.elt_eq f0 v).
  - (* f0=v *)
    inv HfDef.
    unfold translate_function in Hf.
    destruct (translate_var _ _ _ _) eqn:Hvar. inv Hf.
    destruct (translate_body _ _ _ _ _) eqn:Hexp; inv Hf.
    exists u, l. eexists. eexists. eexists.
    now econstructor.
    do 2! (split; try reflexivity). now left.
    cbn. rewrite map_repeat_eq.
    repeat split=>//.
    eapply translate_body_correct in Hexp; eauto. eapply HcorrCenv with (f:=v). cbn.
    by destruct (M.elt_eq v v).
  - (* f0<>v *)
    assert (Hnodup': NoDup (collect_function_vars (Efun fds e0))) by inv Hnodup=>//.
    assert (HcorrCenv': (forall (f : var) (t : fun_tag) (ys : seq var) (e : exp),
      find_def f fds = Some (t, ys, e) ->
      correct_cenv_of_exp cenv e)). {
      intros. have H' := HcorrCenv f1 t0 ys0 e1. apply H'. cbn.
      assert (f1 <> v). {
        inv Hnodup. intro. subst. apply H2.
        apply find_def_in_collect_function_vars; auto. congruence. }
      now destruct (M.elt_eq f1 v).
    }
    have IH := IHfds _ _ _ _ _ _ _ Hnodup' Hfns HfDef HcorrCenv'.
    destruct IH as [idx [e' [locs [func [? [? [? [? [? [? [? ?]]]]]]]]]]].
    inversion H. subst. inv H.
    repeat eexists; eauto. now right.
Qed.

Lemma unique_export_names_preserves_functions : forall fns mi,
  [seq gen_func_instance {| modfunc_type := type a
                          ; modfunc_locals := locals a
                          ; modfunc_body := body a
                          |} mi | a <- unique_export_names fns] =
  [seq gen_func_instance {| modfunc_type := type a
                          ; modfunc_locals := locals a
                          ; modfunc_body := body a
                          |} mi | a <- fns].
Proof.
  intro fns.
  unfold unique_export_names. unfold mapi.
  remember 0 as idx. clear Heqidx.
  revert fns idx.
  induction fns; intros=>//. cbn.
  rewrite (mapi_aux_acc_snoc _ _ []).
  cbn. f_equal. now rewrite IHfns.
Qed.

Lemma gen_fun_instance_simplify_eq : forall fns mi,
  (Z.of_nat (length fns) <= max_num_functions)%Z ->
  (forall fn, In fn fns -> type fn <= 100)%N ->
  inst_types mi = list_function_types (Pos.to_nat 100) ->
  [seq gen_func_instance {| modfunc_type := type fn; modfunc_locals := locals fn; modfunc_body := body fn |} mi
     | fn <- fns] =
  [seq FC_func_native (Tf (repeat (T_num T_i32) (N.to_nat (type fn))) [::])
         (f_inst {| f_locs := [::]; f_inst := mi |})
         {| modfunc_type := type fn; modfunc_locals := locals fn; modfunc_body := body fn |}
     | fn <- fns].
Proof.
  induction fns; intros=>//. cbn. f_equal.
  - unfold gen_func_instance. rewrite H1.
    assert (type a <= 100)%N by (apply H0; cbn; auto).
    unfold lookup_N. cbn.
    rewrite (nth_error_nth' _ (Tf [] [])). 2:{ rewrite length_list_function_types. lia. }
    rewrite nth_list_function_types; auto; lia.
  - cbn in H. apply IHfns; auto; try lia.
    intros. by apply H0; cbn; auto.
Qed.

Lemma init_elems_effect : forall num_funs state sr fr mi r_inits idx,
  Forall2
  (fun (e1 : module_element) (rs : seq value_ref) =>
   Forall2
     (fun (bes : seq basic_instruction) (r : value_ref) =>
      reduce_trans
        (state, sr, fr, to_e_list bes)
        (state, sr, fr, [:: vref_to_e r])) (modelem_init e1) rs)
  (table_element_mapping num_funs idx) r_inits ->
  fr.(f_inst).(inst_funcs) = mi.(inst_funcs) ->
  inst_funcs mi = funcidcs num_funs 0%N ->
  inst_elems mi = iota_N 0 num_funs ->
  s_elems sr = [ seq {| eleminst_type := modelem_type elem; eleminst_elem := refs |} |
                          '(elem, refs) <- combine (table_element_mapping num_funs 0) r_inits ] ->

  (forall x, N.to_nat x < num_funs -> selem sr mi x = Some (Build_eleminst T_funcref [:: VAL_ref_func (N.of_nat idx + x)%N])).
Proof.
  intros ??????????????. unfold selem. rewrite H2. unfold lookup_N.
  rewrite iota_N_lookup; last by apply /ssrnat.leP.
  rewrite N2Nat.id. rewrite H3. rewrite nth_error_map.
  erewrite nth_error_nth'. 2:{ rewrite length_combine table_element_mapping_length.
                               apply Forall2_length in H. rewrite table_element_mapping_length in H. lia. }
  erewrite combine_nth. 2:{ apply Forall2_length in H. now rewrite -> table_element_mapping_length in *. }
  erewrite nth_error_nth; last by eapply table_element_mapping_nth_error.
  have H' := table_element_mapping_nth_error _ idx _ H4.
  assert (exists l, nth_error r_inits (N.to_nat x) = Some l) as [l Hl]. {
    apply notNone_Some. apply nth_error_Some.
    apply Forall2_length in H. rewrite table_element_mapping_length in H. lia.
  }
  have H'' := Forall2_nth_error H H' Hl. cbn in H''. inv H''. inv H9. cbn in H7.
  cbn. erewrite nth_error_nth; last eassumption.
  apply Operators_Properties.clos_rt_rt1n_iff in H7. inv H7. destruct y=>//.
  destruct y0 as [[[??]?]?]. apply reduce_ref_func in H5.
  destruct H5 as [addr [Hf ->]]. rewrite H0 H1 in Hf. unfold lookup_N in Hf.
  erewrite nth_error_funcidcs in Hf; eauto.
  2:{ apply Some_notNone in Hf. apply nth_error_Some in Hf. rewrite funcidcs_length in Hf. lia. }
  rewrite N2Nat.id in Hf. cbn in Hf. inv Hf.
  apply Operators_Properties.clos_rt_rt1n_iff in H6.
  apply reduce_trans_value with (v2:=VAL_ref y) in H6.
  inv H6. repeat f_equal. lia.
Unshelve. repeat constructor. apply [].
Qed.

Lemma parse_print_inv: forall x,
  String.print (String.parse x) = x.
Proof.
  induction x; intros; cbn; auto.
  congruence.
Qed.

Lemma string_print_inj : forall x y,
  String.print x = String.print y ->
  x = y.
Proof.
  induction x; destruct y; intros=>//.
  inv H. apply IHx in H2. now subst.
Qed.

Lemma string_of_nat_no_underscore : forall n,
  ~ In "_"%byte (String.print (string_of_nat n)).
Proof.
  unfold string_of_nat.
  intro n.
  induction (Nat.to_uint n); intros; cbn; intro; by destruct H.
Qed.

(* prefixed id only occurs once *)
Lemma unique_export_names_smaller_idx_not_In : forall fns name idx idx' post_fix,
  idx' < idx ->
  name = "_"%byte :: String.print (string_of_nat idx') ++ "_"%byte :: "_"%byte :: post_fix ->
  ~ In name
  (List.map
     (fun x : wasm_function =>
      String.print (export_name x))
     (mapi_aux (idx, [::])
        (fun (i : nat) (fn : wasm_function) =>
         {| fidx := fidx fn
          ; export_name := sanitize_function_name (export_name fn) i
          ; type := type fn
          ; locals := locals fn
          ; body := body fn
          |}) fns)).
Proof.
  induction fns; intros; subst; intro.
  - inv H0.
  - cbn in H0.
    rewrite (mapi_aux_acc_snoc _ _ []) in H0. destruct H0 as [Hc|Hc].
    + cbn in Hc.
      rewrite -app_assoc in Hc.
      rewrite parse_print_inv in Hc.
      injection Hc as Hc.
      remember (List.map _ _) as post_fix'. clear Heqpost_fix'.
      apply app_eq_app in Hc as [l Hl]. destruct Hl as [[Hl1 Hl2] | [Hl1 Hl2]].
      * destruct l.
        -- erewrite cats0 in Hl1.
           apply string_print_inj in Hl1.
           apply string_of_nat_inj in Hl1. lia.
        -- injection Hl2 as <-.
           apply string_of_nat_no_underscore with (n:=idx).
           rewrite Hl1. apply in_app_iff. now cbn.
      * destruct l.
        -- erewrite cats0 in Hl1.
           apply string_print_inj in Hl1.
           apply string_of_nat_inj in Hl1. lia.
        -- injection Hl2 as <-.
           apply string_of_nat_no_underscore with (n:=idx').
           rewrite Hl1. apply in_app_iff. now cbn.
    + eapply IHfns in Hc; eauto. lia.
Qed.

(* export names prefixed with an underscore and unique id *)
Lemma unique_export_name_NoDup : forall fns names,
  names = List.map (fun x : wasm_function => String.print (export_name x))
                   (unique_export_names fns) ->
  NoDup names /\
  forall n, In n names -> nth_error n 0 = Some "_"%byte.
Proof.
  unfold unique_export_names, mapi. intros.
  remember 0 as idx in H. clear Heqidx. revert fns idx names H.
  induction fns; intros; subst names.
  - split. apply NoDup_nil. intros. inv H.
  - cbn. rewrite (mapi_aux_acc_snoc _ _ []).
    have IH := IHfns (idx + 1) _ Logic.eq_refl. destruct IH as [IH1 IH2].
    split.
    + constructor.
      eapply unique_export_names_smaller_idx_not_In with (idx':=idx). lia.
      cbn. rewrite parse_print_inv. f_equal.
      now rewrite -app_assoc.
      by apply IH1.
    + intros.
      apply In_nth_error in H as [i Hnth].
      rewrite nth_error_map in Hnth. cbn in Hnth.
      destruct (nth_error _ _) eqn:He=>//. injection Hnth as <-.
      destruct i.
      * cbn in He. now injection He as <-.
      * apply IH2. eapply nth_error_In.
        rewrite nth_error_map'.
        cbn in He. cbn. now erewrite He.
Qed.

Theorem module_instantiate : forall e module fenv venv (hs : host_state),
  correct_cenv_of_exp cenv e ->
  NoDup (collect_function_vars e) ->
  LambdaANF_to_Wasm nenv cenv penv e = Ret (module, fenv, venv) ->
  exists sr fr es_post,
  instantiate initial_store module [] (sr, fr, es_post).
Proof.
  intros ????? Hcenv Hnodup H. unfold LambdaANF_to_Wasm in H.
  destruct (check_restrictions cenv e) eqn:Hrestr. inv H. destruct u.
  eapply check_restrictions_expression_restricted in Hrestr; last by apply rt_refl.
  destruct e =>//.
  destruct (translate_functions _ _ _ _ f) eqn:Hfuns. inv H.
  rename l into fns, f into fds. cbn in H.
  destruct (translate_body nenv cenv _ _) eqn:Hexpr. inv H.
  rename l into wasm_main_instr.

  remember (list_function_types (Z.to_nat max_function_args)) as ts. rewrite -Heqts in H.
  inversion H. clear H. cbn. rename venv into lenv.

  destruct (interp_alloc_module initial_store module []
             ((repeat (VAL_num (nat_to_value 0)) 4) ++ (repeat (VAL_num (nat_to_value64 0)) 4))
                                (elem_vals (Datatypes.length fns + num_custom_funs) 0))
        as [s' inst] eqn:HallocM.

  subst module.
  rewrite Heqts in HallocM.

  (* final store *)
  exists s'.
  (* module instance *)
  exists (Build_frame [] inst).
  (* es_post: instructions post-instantiation *)
  exists (concat (mapi_aux (0, [::]) (fun n : nat => get_init_expr_elem n)
                                     (table_element_mapping (length fns + num_custom_funs) 0))).
  (* import types *)
  exists []. exists [].

  (* export types *)
  exists ([:: ET_func (Tf [::] [::])] ++  (* main *)
         map (fun f => ET_func (Tf (repeat (T_num T_i32) (N.to_nat f.(type))) [::])) fns ++ (* all fns exported *)
         [:: ET_global {| tg_mut := MUT_var; tg_t := T_num T_i32 |}
           ; ET_global {| tg_mut := MUT_var; tg_t := T_num T_i32 |}
           ; ET_global {| tg_mut := MUT_var; tg_t := T_num T_i32 |}           (* global vars *)
           ; ET_mem {| lim_min := 1%N; lim_max := Some max_mem_pages|}]).     (* global mem *)
  exists hs.
  exists inst.
  (* initial values of globals: 0 *)
  exists ((repeat (VAL_num (nat_to_value 0)) 4) ++ (repeat (VAL_num (nat_to_value64 0)) 4)).
  (* element values (table entries) *)
  exists (elem_vals (length fns + num_custom_funs) 0).

  repeat split.
  (* module typing *) {
  - unfold module_typing. simpl.
    (* function types *)
    exists ([:: Tf [::] [::]] ++ (* main, fns *)
             map (fun f => Tf (repeat (T_num T_i32) (N.to_nat (type f)))[::]) fns).
    (* table types *)
    exists ([{| tt_limits := {| lim_min := N.of_nat (length fns + num_custom_funs);
                                lim_max := None |}
              ; tt_elem_type := T_funcref |}]).
    (* mem types *)
    exists [{| lim_min := 1%N; lim_max := Some max_mem_pages |}].
    (* global types *)
    exists ((repeat ({| tg_mut := MUT_var; tg_t := T_num T_i32 |}) 4) ++ (repeat ({| tg_mut := MUT_var; tg_t := T_num T_i64 |}) 4)).
    (* elem types *)
    exists (repeat T_funcref (length fns + num_custom_funs)).
    (* data types *)
    exists [].

    repeat split=>//.
    + (* func_types valid *)
      subst ts. by apply list_function_types_valid.
    + (* module_func_typing *)
      apply Forall2_cons.
      { (* main func *)
        subst ts. cbn. repeat split =>//.
        apply translate_body_correct in Hexpr.
        2:{ eapply Forall_constructors_subterm. eassumption.
            apply t_step. by apply dsubterm_fds2. }
        eapply repr_expr_LambdaANF_Wasm_typing =>//; last by eassumption.
        2: { (* expr restr *) by inv Hrestr. }
        repeat split =>//.
        * (* locals in bound *)
          intros ?? Hvar. cbn.
          unfold lookup_N. rewrite nth_error_map.
          destruct (nth_error _ (N.to_nat x')) eqn:Hcontra =>//.
          inv Hvar. apply var_mapping_list_lt_length in H.
          by apply nth_error_Some in H.
        * (* i32 globals *)
          intros var Hin. cbn.
          by repeat destruct Hin as [|Hin]; subst =>//.
        * (* i64 globals *)
          intros var Hin. cbn.
          by repeat destruct Hin as [|Hin]; subst =>//.
        * (* table *)
          eexists. cbn. split; reflexivity.
        * (* types *)
          intros ? Hmax. cbn. unfold max_function_args in Hmax. unfold lookup_N.
          erewrite nth_error_nth'; first rewrite nth_list_function_types =>//.
          by rewrite Nat2N.id. lia. rewrite length_list_function_types. lia.
          apply notNone_Some. rewrite <- map_repeat_eq.
          eexists. apply default_vals_i32_Some.
      }
      { (* funcs *)
        apply Forall2_spec.
        { rewrite length_map length_is_size length_is_size
            size_map -length_is_size.
          now erewrite <- mapi_length.
        }
        intros ?? [t1s t2s] Hnth1 Hnth2. cbn. unfold module_func_typing.
        repeat split =>//.
        rewrite nth_error_map in Hnth1. simpl in Hfuns.
        unfold unique_export_names in Hnth1.
        destruct (nth_error fns n) eqn:Hin. 2:{ by rewrite mapi_nth_error_None in Hnth1. }
        erewrite mapi_nth_error in Hnth1; eauto. cbn in Hnth1.
        destruct m. injection Hnth1 as <-<-<-.
        rewrite nth_error_map in Hnth2. rewrite Hin in Hnth2.
        injection Hnth2 as Hnth2. subst t1s t2s.
        assert (n = N.to_nat (fidx w) - num_custom_funs).
        { eapply translate_functions_nth_error_idx; eauto. } subst n.

        have H' := translate_functions_exists_original_fun fds fds fns
          _ _ _ _ Hnodup Hfuns Logic.eq_refl (nth_error_In _ _ Hin).
        destruct H' as [f [t [ys [e1 [Hfd [Htype Hvarr]]]]]].

        assert (HcenvFds : (forall (f : var) (t : fun_tag) (ys : seq var) (e : exp),
            find_def f fds = Some (t, ys, e) -> correct_cenv_of_exp cenv e)). {
          intros ???? Hfd'.
          eapply Forall_constructors_subterm. eassumption.
          apply t_step. apply dsubterm_fds. now eapply find_def_dsubterm_fds_e.
        }
        have H' := translate_functions_find_def fds _ _ _ _ e1 _ _ Hnodup Hfuns Hfd HcenvFds.

        destruct H' as [f' [e' [locs [func [Hvar [-> [Hin' [<- [Hty [Hlocs [<- Hexpr']]]]]]]]]]].
        assert (func = w). {
          assert (Heq: fidx func = fidx w). {
            inv Hvar. inv Hvarr. unfold translate_var in H, H0.
            destruct ((create_fname_mapping (Efun fds e)) ! f) eqn:Hf;
              rewrite Hf in H, H0; congruence.
          }
          apply In_nth_error in Hin'. destruct Hin' as [j Hj].
          assert (j = N.to_nat (fidx func) - num_custom_funs).
            eapply translate_functions_nth_error_idx; try apply Hfuns; eauto.
          congruence.
        } subst w. clear Hvarr Hin'.

        split. { inv Hrestr.
          apply H5 in Hfd. destruct Hfd as [Hfd _].
          unfold lookup_N. erewrite nth_error_nth'.
          rewrite nth_list_function_types; auto. lia.
          rewrite length_list_function_types. lia. }
        split.
        eapply repr_expr_LambdaANF_Wasm_typing =>//; last by apply Hexpr'.
        { (* context restrictions *)
          repeat split =>//.
          * (* locs i32 *)
            intros ?? Hvar'.
            rewrite Hlocs Htype Nat2N.id. unfold lookup_N. cbn.
            rewrite <-repeat_app, <-length_app.
            apply nth_error_repeat. inv Hvar'. now eapply var_mapping_list_lt_length.
          * (* i32 globals *)
            intros ? Hin'. cbn. by repeat destruct Hin' as [|Hin']; subst =>//.
          * (* i64 globals *)
            intros ? Hin'. cbn. by repeat destruct Hin' as [|Hin']; subst =>//.
          * (* table *)
            eexists. cbn. unfold lookup_N. split; reflexivity.
          * (* length *)
            cbn. subst ts. rewrite length_list_function_types. lia.
          * (* types *)
            intros ? Hmax. unfold lookup_N. cbn. subst ts.
            erewrite nth_error_nth'. rewrite nth_list_function_types.
            now rewrite Nat2N.id. lia.
            rewrite length_list_function_types. lia.
        }
        { inv Hfd. inv Hrestr. now eapply H4. }
        { rewrite Hlocs. apply notNone_Some. eexists. apply default_vals_i32_Some. }
      }
    + (* module_table_typing *)
      apply Forall2_cons. unfold module_table_typing, tabletype_valid, limit_valid_range. cbn.
      assert (HfnsBound: (N.of_nat (Datatypes.length fns + num_custom_funs) <= 4294967295)%N).
      { apply translate_functions_length in Hfuns. rewrite -Hfuns.
        inv Hrestr. unfold num_custom_funs.
        unfold max_num_functions in H6. lia. }
      apply N.leb_le in HfnsBound. rewrite HfnsBound. by apply /eqtable_typeP.
      apply Forall2_nil.
    + (* module_mem_typing *)
      apply Forall2_cons=>//.
    + (* module_glob_typing *)
      repeat (apply Forall2_cons; repeat split; try by apply bet_const_num =>//).
      by apply Forall2_nil.
    + (* module_elem_typing *)
      simpl. eapply module_typing_module_elem_typing=>//. clear HallocM.
      simpl. { intros n Hn. unfold lookup_N in Hn. apply nth_error_Some in Hn. cbn in Hn.
        rewrite length_is_size size_map -length_is_size in Hn.
        apply nodup_In. simpl. apply in_or_app. left.
        apply nodup_In. apply funcidx_in_table_element_mapping with (idx:=0).
        unfold num_custom_funs. lia. }
    + (* module_export_typing *)
      apply Forall2_cons.
      { (* main func *)
        now cbn. }
      apply Forall2_app.
      { (* fns *)
        intros. cbn.
        apply Forall2_spec. { repeat rewrite length_map. now erewrite <-mapi_length. }
        intros ??? Hnth1 Hnth2. rewrite nth_error_map in Hnth2.
        destruct (nth_error fns n) eqn:Hnth =>//.
        rewrite nth_error_map in Hnth1.
        unfold unique_export_names in Hnth1.
        erewrite mapi_nth_error in Hnth1; eauto. cbn in Hnth1.
        destruct m. injection Hnth1 as <-<-.
        injection Hnth2 as <-.
        assert (n = N.to_nat (fidx w) - num_custom_funs). {
          now eapply translate_functions_nth_error_idx; eauto. } subst n. cbn.
        assert (Hbounds: (N.of_nat num_custom_funs <= fidx w < N.of_nat (length fns + num_custom_funs))%N). {
          eapply translate_functions_idx_bounds; eauto.
          2:{ apply In_map. now eapply nth_error_In. }
          intros. split; first by apply local_variable_mapping_gt_idx in H; lia.
          assert (Hvar: translate_var nenv (create_fname_mapping (Efun fds e)) f ""%bs = Ret f')
            by (unfold translate_var; rewrite H=>//). clear H.
          have H' := Hvar.
          apply var_mapping_list_lt_length' in Hvar.
          rewrite collect_function_vars_length in Hvar.
          erewrite (translate_functions_length _ fns) in Hvar; eauto. lia.
        }
        unfold num_custom_funs in *. unfold lookup_N.
        destruct (N.to_nat (fidx w)) eqn:Hidx; first by lia. cbn in Hnth.
        rewrite Nat.sub_0_r in Hnth. cbn.
        rewrite nth_error_map. rewrite Hnth. by apply /eqfunction_typeP.
      }
      (* global vars, memory *)
      repeat apply Forall2_cons =>//.
      (* export names unique *)
      apply /eqseqP.
      apply nodup_fixed_point. cbn.
      erewrite map_app, map_map. cbn.
      have H' := unique_export_name_NoDup fns _ Logic.eq_refl.
destruct H' as [HnoDup H_].
      eapply Permutation_NoDup.
      have Hperm := Permutation_app_rot _
                      [ String.print main_function_name ]
                      (List.map (fun x : wasm_function => String.print (export_name x))
                      (unique_export_names fns)).
      apply Hperm.
      repeat (constructor; first
                (intro Hc; repeat (destruct Hc as [Hc|Hc]=>//); by apply H_ in Hc)).
      assumption.
    }
  - (* imports typing *)
    by apply Forall2_nil.
  - (* imports subtyping *)
    by apply Forall2_nil.
  - (* alloc_module is true *) { cbn.
    unfold interp_alloc_module, initial_store in HallocM.
    destruct (alloc_funcs _ _ _) eqn:Hfuncs.
    have Hfuncs' := Hfuncs.
    apply alloc_func_iota_N in Hfuncs.
    rewrite <- Heqts in *. (* prevent unfolding of types *)
    cbn in HallocM.

    destruct Hfuncs as [Hfuncs1 [Hfuncs2 [Hfuncs3 [Hfuncs4 [Hfuncs5 [Hfuncs6 Hfuncs7]]]]]].
    cbn in Hfuncs1, Hfuncs2, Hfuncs3, Hfuncs4, Hfuncs5, Hfuncs6, Hfuncs7.

    destruct (alloc_elems _ _ _) eqn:Helems.
    injection HallocM as <-<-.
    have Helems' := Helems.
    apply alloc_elem_iota_N in Helems. cbn in Helems.
    rewrite Hfuncs2 -Hfuncs3 -Hfuncs4 -Hfuncs5 -Hfuncs6 -Hfuncs7 in Helems.
    (*  clear Hfuncs2 Hfuncs3 Hfuncs4 Hfuncs5 Hfuncs6 Hfuncs7. *)
    destruct Helems as [Helems1 [Helems2 [Helems3 [Helems4 [Helems5 [Helems6 Helems7]]]]]].
    cbn in Helems1, Helems2, Helems3, Helems4, Helems5, Helems6, Helems7.

    rewrite Hfuncs'. rewrite Helems'. cbn. clear Hfuncs' Helems'.
    (* rewrite Helems1. -Helems2. Helems3. -Helems4 -Helems5. *)

    rewrite Hfuncs1 -Hfuncs3 -Hfuncs4 -Hfuncs5.
    repeat split=>//.
    by rewrite table_element_mapping_length elem_vals_length. }
  - (* instantiate globals *)
    unfold instantiate_globals. cbn.
    repeat (apply Forall2_cons; first by apply rt_refl).
    by apply Forall2_nil.
  - (* instantiate elem *)
    unfold instantiate_elems. cbn. unfold interp_alloc_module in HallocM.
    destruct (alloc_funcs _ _ _) eqn:Hfuncs.
    apply alloc_func_iota_N in Hfuncs. cbn in Hfuncs. cbn in HallocM.
    destruct (alloc_elems _ _) eqn:Helems.
    injection HallocM as <-.
    apply elems_instantiate. subst inst. cbn.
    rewrite Nat.add_comm. rewrite length_map.
    unfold unique_export_names. now erewrite <-mapi_length.
  - by rewrite cats0.
Unshelve. all: apply (Tf [] []).
Qed.

End INSTANTIATION.


Section POST_INSTANTIATION.

Import host instantiation_spec.
Import Lia.
Import Relations.Relation_Operators.

Variable cenv:LambdaANF.cps.ctor_env.
Variable funenv:LambdaANF.cps.fun_env.
Variable nenv : LambdaANF.cps_show.name_env.
Variable penv : LambdaANF.toplevel.prim_env.

Context `{ho : host}.

(* The following are slightly different than the ones in utils: isolate instr. + n leading args, e.g. with n=2 for add:
   [const 1, const 2, add, remaining instr] => [const 1, const 2, add]  *)
Ltac elimr_nary_instr n :=
  let H := fresh "H" in
  match n with
  | 0 => lazymatch goal with
         | |- reduce _ _ _ ([:: ?instr])        _ _ _ _ => idtac
         | |- reduce _ _ _ ([:: ?instr] ++ ?l3) _ _ _ _ => apply r_elimr
         end
  | 1 => lazymatch goal with
         | |- reduce _ _ _ ([::$VN ?c1] ++ [:: ?instr])        _ _ _ _ => idtac
         | |- reduce _ _ _ ([::$VN ?c1] ++ [:: ?instr] ++ ?l3) _ _ _ _ =>
            assert ([:: $VN c1] ++ [:: instr] ++ l3 =
                    [:: $VN c1; instr] ++ l3) as H by reflexivity; rewrite H;
                                                       apply r_elimr; clear H
         end
  | 2 => lazymatch goal with
         | |- reduce _ _ _ ([::$VN ?c1] ++ [::AI_ref ?r] ++ [:: ?instr]) _ _ _ _ => idtac
         | |- reduce _ _ _ ([::$VN ?c1] ++ [::AI_ref ?r] ++ [:: ?instr] ++ ?l3) _ _ _ _ =>
            assert ([:: $VN c1] ++ [:: AI_ref r] ++ [:: instr] ++ l3 =
                    [:: $VN c1; AI_ref r; instr] ++ l3) as H by reflexivity; rewrite H;
                                                       apply r_elimr; clear H
         end
  | 3 => lazymatch goal with
         | |- reduce _ _ _ ([::$VN ?c1] ++ [::$VN ?c2] ++ [::$VN ?c3] ++ [:: ?instr])        _ _ _ _ => idtac
         | |- reduce _ _ _ ([::$VN ?c1] ++ [::$VN ?c2] ++ [::$VN ?c3] ++ [:: ?instr] ++ ?l3) _ _ _ _ =>
            assert ([:: $VN c1] ++ [::$VN c2] ++ [::$VN c3] ++ [:: instr] ++ l3 =
                    [:: $VN c1; $VN c2; $VN c3; instr] ++ l3) as H by reflexivity; rewrite H;
                                                       apply r_elimr; clear H
         end
  end.

Ltac dostep :=
  eapply rt_trans with (y := (?[hs], ?[sr], ?[f'], ?[s] ++ ?[t]));
  first (apply rt_step; separate_instr).

(* only returns single list of instructions *)
Ltac dostep' :=
   eapply rt_trans with (y := (?[hs], ?[sr], ?[f'], ?[s]));
   first (apply rt_step; separate_instr).

Ltac dostep_nary n :=
  dostep; first elimr_nary_instr n.

Ltac dostep_nary' n :=
  dostep'; first elimr_nary_instr n.


Definition INV_instantiation_elems s f num_funs :=
  (forall x, N.to_nat x < num_funs ->
             selem s f.(f_inst) x = Some (Build_eleminst T_funcref [:: VAL_ref_func x])) /\
  inst_elems f.(f_inst) = iota_N 0 num_funs.

Definition INV_instantiation_table_empty s f num_funs :=
  f.(f_inst).(inst_tables) = [0%N] /\
  s.(s_tables) = [ {| tableinst_type := {| tt_limits := {| lim_min := N.of_nat num_funs
                                                         ; lim_max := None |}
                                         ; tt_elem_type := T_funcref |}
                    ; tableinst_elem := repeat (VAL_ref_null T_funcref) num_funs
                    |}].

(* invariants that hold after instantiation, but before post-instantiation,
   the table is initialised during post-instantiation, so INV_table_id doesn't yet hold here *)
Definition INV_instantiation (s : store_record) (f : frame) (num_funs : nat) :=
(* same as INV *)
    INV_glob_result_writable s f
 /\ INV_glob_out_of_mem_writable s f
 /\ INV_glob_out_of_mem_is_zero s f
 /\ INV_glob_mem_ptr_writable s f
 /\ INV_glob_cap_writable s f
 /\ INV_globals_all_mut s f
 /\ INV_linear_memory s f
 /\ INV_glob_mem_ptr_in_linear_memory s f
 /\ INV_locals_all_i32 f
 /\ INV_num_functions_bounds s f
 /\ INV_inst_globals_nodup f
 /\ INV_types f
 /\ INV_glob_mem_ptr_multiple_of_two s f
 /\ INV_inst_funcs_id s f
 /\ INV_i64_glob_tmps_writable s f
(* additional *)
 /\ INV_instantiation_elems s f num_funs
 /\ INV_instantiation_table_empty s f num_funs.


Theorem module_instantiate_INV_and_more_hold : forall eAny e fds num_funs module fenv main_lenv sr f es_post,
  NoDup (collect_function_vars (Efun fds eAny)) ->
  expression_restricted cenv (Efun fds e) ->
  (forall (f : var) (t : fun_tag) (ys : seq var) (e : exp),
      find_def f fds = Some (t, ys, e) -> correct_cenv_of_exp cenv e) ->
  num_funs = numOf_fundefs fds ->
  (Z.of_nat num_funs <= max_num_functions)%Z ->
  LambdaANF_to_Wasm nenv cenv penv (Efun fds e) = Ret (module, fenv, main_lenv) ->
  (* instantiate with the two imported functions *)
  instantiate initial_store module [] (sr, f, es_post) ->

  (* invariants hold initially *)
  INV_instantiation sr f (num_funs + num_custom_funs) /\
  inst_funcs (f_inst f) = [:: 0%N & (funcidcs num_funs (N.of_nat num_custom_funs))] /\
  (* value relation holds for all funcs in fds *)
  (forall a, find_def a fds <> None ->
	   exists fidx : funcidx,
	     repr_funvar fenv nenv a fidx /\
	     repr_val_LambdaANF_Wasm cenv fenv nenv penv (Vfun (M.empty _) fds a)
                                            sr (f_inst f) (Val_funidx fidx)) /\

  exists main_fn e' fns,
    main_fn = {| modfunc_type := 0%N (* [] -> [] *)
               ; modfunc_locals := map (fun _ : var => T_num T_i32) (collect_local_variables e)
               ; modfunc_body := e'
               |} /\
    s_funcs sr =
    [:: FC_func_native (Tf [::] [::]) (f_inst f) main_fn
    &   map (fun f0 : wasm_function =>
             FC_func_native (Tf (repeat (T_num T_i32) (N.to_nat (type f0))) [::]) (f_inst f)
             {| modfunc_type := type f0; modfunc_locals := locals f0; modfunc_body := body f0 |})
            fns
     ] /\
  es_post = concat (mapi_aux (0, [::]) (fun n : nat => get_init_expr_elem n)
                             (table_element_mapping (Datatypes.length fns + num_custom_funs) 0)) /\
  (* links e and e' in main_fn above *)
  translate_body nenv cenv
          (create_local_variable_mapping
             (collect_local_variables e)) fenv penv e 0 = Ret e' /\
  (* translation of functions *)
  translate_functions nenv cenv fenv penv fds = Ret fns.
Proof.
  intros eAny e fds num_funs module fenv lenv s f es_post Hnodup HeRestr HcenvCorrect ->
    HfnsLength Hcompile Hinst.
  unfold instantiate in Hinst.
  unfold LambdaANF_to_Wasm in Hcompile.
  remember (list_function_types (Z.to_nat max_function_args)) as types.
  destruct (check_restrictions cenv (Efun fds e)) eqn:HRestr. inv Hcompile.
  destruct (translate_functions nenv cenv _ penv fds) eqn:HtransFns. inv Hcompile. simpl in Hcompile.
  destruct (translate_body nenv cenv _ _ _) eqn:Hexpr. inv Hcompile. rename l0 into e'.
  inv Hcompile.
  unfold INV_instantiation. unfold is_true in *.
  destruct Hinst as [t_imps_mod [t_imps [t_exps [state [mi [ g_inits [r_inits
    [Hmodule [Himports [HimportsSt [HallocModule [HinstGlobals [HinstElem [Hframe HinitExprs]]]]]]]]]]]]]].
  rename l into fns. cbn in HinitExprs.

  (* globals red. to const *)
  unfold instantiate_globals in HinstGlobals. cbn in HinstGlobals.
  inv HinstGlobals. inv H3. inv H5. inv H6. inv H7. inv H8. inv H9. inv H10. cbn in H1.
  apply reduce_trans_value with (v1:=VAL_num (nat_to_value 0)) in H1, H2, H3, H4.
  apply reduce_trans_value with (v1:=VAL_num (nat_to_value64 0)) in H5, H6, H7, H8.
  subst y y0 y1 y2 y3 y4 y5 y6.
  unfold alloc_module, alloc_funcs, alloc_globs, add_mem, alloc_Xs in HallocModule.
  cbn in HallocModule. repeat rewrite map_app in HallocModule. cbn in HallocModule.
  destruct (fold_left _ (map _ (unique_export_names fns)) _) eqn:HaddF.
  destruct (alloc_elems _ _ _) eqn:HallocElems.
  apply alloc_elem_iota_N in HallocElems. 2:{ by apply Forall2_length in HinstElem. }
  cbn in HallocElems.
  destruct HallocElems as [-> [E0 [E1 [E2 [E3 [E4 E5]]]]]].

  destruct HallocModule as [<- [F0 [F1 [F2 [F3 [F4 [F5 [F6 F7]]]]]]]].
  cbn in HaddF.
  rewrite table_element_mapping_length in F5.

  (* main fn *)
  destruct (add_func initial_store _) eqn:HaddF'.
  unfold add_func, gen_func_instance in HaddF'. rewrite F0 in HaddF'.
  replace (Pos.to_nat 100) with 100 in HaddF' by reflexivity. cbn in HaddF'.
  replace (Pos.to_nat 1) with 1 in HaddF' by reflexivity. cbn in HaddF'.
  injection HaddF' as <- <- <- <- <- <-.

  apply add_funcs_effect in HaddF. cbn in HaddF.
  destruct HaddF as [Hs01 [Hs02 [Hs03 [Hs04 [Hs05 [Hs06 ->]]]]]].

  rewrite <- Hs01 in *. rewrite <- Hs02 in *. rewrite <- Hs03 in *.
  rewrite <- Hs04 in *. rewrite <- Hs05 in *. rewrite -> Hs06 in *. cbn in F0.
  (* clear Hs01 Hs02 Hs03 Hs04. *)
  cbn in E0, E1, E2, E3, E4, E5.
  cbn in F0, F1, F2, F3, F4.
  rewrite length_map in F1. rewrite rev_app_distr in F1.
  rewrite rev_involutive in F1. cbn in F1.

  split.
  (* INV *)
  unfold INV_glob_result_writable, INV_glob_out_of_mem_writable,
    INV_glob_mem_ptr_writable, INV_glob_cap_writable, INV_i64_glob_tmps_writable.
  unfold global_var_w, supdate_glob, supdate_glob_s.
  cbn. rewrite F4.
  split. (* res_var_w *)   eexists. rewrite -E3. reflexivity.
  split. (* res_var_M_w *) eexists. rewrite -E3. reflexivity.
  split. (* res_var_M_0 *) unfold INV_glob_out_of_mem_is_zero. unfold sglob_val, sglob.
  cbn. rewrite F4. rewrite -E3. reflexivity.
  split. (* gmp_w *) eexists. rewrite -E3. reflexivity.
  split. (* cap_w *) eexists. rewrite -E3. reflexivity.
  (* globals mut i32 *)
  split.
  unfold INV_globals_all_mut, globals_all_mut, globals_all_mut32, globals_all_mut64.
  split; intros. unfold lookup_N in H1.
  {
    unfold glob_result, glob_out_of_mem, glob_mem_ptr, glob_cap in *.
    cbn in H0; try subst gidx; try rewrite F4 in H0; unfold lookup_N in H0.
    rewrite -E3 in H1. cbn in H1.
    destruct (N.to_nat gidx) eqn:Hgidx. cbn in H0.
    replace g with 0%N in * by congruence. inv H1. now eexists.
    destruct n. cbn in H0.
    replace g with 1%N in * by congruence. inv H1. now eexists.
    destruct n. cbn in H0.
    replace g with 2%N in * by congruence. inv H1. now eexists.
    destruct n. cbn in H0.
    replace g with 3%N in * by congruence. inv H1. now eexists.
    repeat (try destruct H;[now subst gidx|]).
    now inv H.
  }
  {
    unfold glob_tmp1, glob_tmp2, glob_tmp3, glob_tmp4 in *.
    cbn in H0; try subst gidx; try rewrite F4 in H0; unfold lookup_N in H0.
    rewrite -E3 in H1.
    destruct (List.in_inv H).
    { subst gidx. replace (N.to_nat 4) with 4 in * by now cbn. inv H0. inv H1. now eexists. }
    destruct (List.in_inv H2).
    { subst gidx. replace (N.to_nat 5) with 5 in * by now cbn. inv H0. inv H1. now eexists. }
    destruct (List.in_inv H3).
    { subst gidx. replace (N.to_nat 6) with 6 in * by now cbn. inv H0. inv H1. now eexists. }
    destruct (List.in_inv H4).
    { subst gidx. replace (N.to_nat 7) with 7 in * by now cbn. inv H0. inv H1. now eexists. }
    now inv H5.
  }
  split. (* linmem *)
  { unfold INV_linear_memory. unfold smem. cbn. rewrite F3.
    split; auto. unfold smem. eexists; auto.
    split. rewrite -E2. reflexivity.
    eexists. split. reflexivity.
    split. reflexivity.
    unfold max_mem_pages, gen_mem_instance, mem_size, mem_length. cbn.
    rewrite memory.mem_make_length. cbn. lia. }
   split. (* gmp in linmem *)
   { unfold INV_glob_mem_ptr_in_linear_memory.
     unfold sglob_val, sglob. cbn. intros ?? Hm Hm0 Hbound. unfold smem in Hm.
     rewrite F3 in Hm0, Hm. rewrite -E2 in Hm. rewrite -E3 F4 in Hm0.
     inv Hm. inv Hm0.
     cbn.
     unfold gen_mem_instance, mem_length. rewrite memory.mem_make_length. cbn.
     rewrite Wasm_int.Int32.Z_mod_modulus_id in H0; lia. }
   split. (* all locals i32 *)
   { unfold INV_locals_all_i32. intros. rewrite nth_error_nil in H. inv H. }
   split. (* num functions upper bound *)
   { unfold INV_num_functions_bounds, max_num_functions.
     split.
     - cbn. rewrite -E0. cbn.
       do 2! rewrite length_map.
       inv HtransFns.
       unfold unique_export_names. erewrite <-mapi_length; eauto.
       erewrite <- translate_functions_length; eauto.
       unfold max_num_functions in HfnsLength. simpl_modulus. cbn. lia.
     - cbn. rewrite F5. rewrite iota_N_length. unfold num_custom_funs.
       erewrite <- translate_functions_length; eauto.
       unfold max_num_functions in HfnsLength. lia. }
   split. (* inst_globals (f_inst f) no dups *)
   unfold INV_inst_globals_nodup. rewrite F4.
   repeat constructor; cbn; lia.
  split. (* types *)
  { unfold INV_types. intros. unfold stypes. cbn. unfold max_function_args in H.
    rewrite F0. unfold lookup_N. erewrite nth_error_nth'.
    rewrite nth_list_function_types =>//. lia.
    rewrite length_list_function_types. lia. }
  split. (* gmp multiple of two *)
  { unfold INV_glob_mem_ptr_multiple_of_two.
    intros ?? Hm Hgmp Hbound. exists 0%N.
    unfold glob_mem_ptr, sglob_val, sglob in Hgmp.
    rewrite -E3 in Hgmp. cbn in Hgmp. rewrite F4 in Hgmp. inv Hgmp.
    rewrite Wasm_int.Int32.Z_mod_modulus_id in H0; lia. }
  split. (* inst_funcs_id *)
  { unfold INV_inst_funcs_id. intros ? Hbound. cbn. rewrite F1. unfold lookup_N.
    remember (N.to_nat i) as i'.
    destruct (Nat.leb_spec i' 0).
    { (* n <= 0 *)
      do 1 (destruct i'; cbn; f_equal; try lia). }
    { (* 0 < n *)
      separate_instr. (* rewrite catA. *)
      erewrite nth_error_app2=>//. cbn.
      erewrite nth_error_funcidcs; eauto.
      f_equal. lia. unfold num_custom_funs in *.
      rewrite -E0 in Hbound. cbn in Hbound.
      do 2! rewrite length_map in Hbound. lia. }
  }
  split. (* i64 globs writable *)
  { intros gidx [Htmp1 | [Htmp2 | [Htmp3 | [Htmp4 | Hfls]]]]; intro v.
    all: eexists; unfold glob_tmp1, glob_tmp2, glob_tmp3, glob_tmp4 in *; auto; subst gidx.
    all: rewrite -E3; cbn; unfold Pos.to_nat in *; rewrite F4; reflexivity.
  }
  split. (* instantiation_elems *)
  { unfold INV_instantiation_elems.
    apply translate_functions_length in HtransFns. split.
    - intros. erewrite init_elems_effect; eauto.
      f_equal; lia. rewrite F1.
      unfold unique_export_names. erewrite <- mapi_length; eauto.
      by rewrite Nat.add_comm. congruence.
    - rewrite F5. cbn. congruence.
  }
  (* instantiate table *)
  { unfold INV_instantiation_table_empty. cbn. split.
    - rewrite F2. reflexivity.
    - rewrite -E1. cbn.
      apply translate_functions_length in HtransFns. repeat f_equal; try lia.
  }
  split. (* inst_funcs (f_inst f) *)
  { rewrite F1. repeat f_equal.
    inv HtransFns; auto.
    unfold unique_export_names. erewrite <-mapi_length;eauto.
    symmetry. eapply translate_functions_length. eassumption. }
  split. (* val relation holds for functions *)
  { intros. apply notNone_Some in H. destruct H as [[[v' ys'] e''] Hfd].

    have H' := translate_functions_find_def _ _ _ _ _ _ _ _ e'' _ _ Hnodup HtransFns Hfd HcenvCorrect.
    destruct H' as [fidx [e''' [? [func [? [? [? [? [? [? [? ?]]]]]]]]]]].
    subst. eauto.
    exists (fidx func).
    split. { inv H. unfold translate_var. unfold translate_var in H0.
      destruct ((create_fname_mapping (Efun fds e)) ! a) eqn:Hmap; rewrite Hmap in H0=>//.
      injection H0 as ->. econstructor.
      unfold translate_var. now rewrite Hmap. }
    econstructor; eauto. rewrite -E0. cbn.
    unfold lookup_N.
    assert ((N.to_nat (fidx func)) >= num_custom_funs). {
      inv H. unfold translate_var in H0.
      destruct ((create_fname_mapping (Efun fds e)) ! a) eqn:Ha;
        rewrite Ha in H0=>//. injection H0 as ->.
      apply local_variable_mapping_gt_idx in Ha. lia. }

    assert (nth_error fns ((N.to_nat (fidx func)) - num_custom_funs) = Some func). {
      apply In_nth_error in H1. destruct H1 as [j Hj].
      erewrite <- translate_functions_nth_error_idx; eauto. }
    unfold num_custom_funs in *.

    assert (HnodupFns: NoDup fns). {
      assert (Hinj: map_injective (create_fname_mapping (Efun fds e))). {
        by apply create_local_variable_mapping_injective. }
      have H' := translate_functions_NoDup _ _ _ _ _ _ _ _ Logic.eq_refl Hinj Hnodup HtransFns.
      now eapply NoDup_map_inv.
    }

    destruct (N.to_nat (fidx func)). lia. cbn.
    replace (_ - _) with n in H2 by lia.

    do 2! rewrite nth_error_map.
    unfold unique_export_names.
    erewrite mapi_nth_error; eauto.
    cbn. f_equal. unfold gen_func_instance.
    rewrite F0. cbn. f_equal. rewrite H4.
    assert (HtypeBound : (type func <= 100)%N). {
      inv HeRestr.
      eapply translate_functions_type_bound; eauto.
    }
    unfold lookup_N. erewrite nth_error_nth'. 2:{ rewrite length_list_function_types. lia. }
    rewrite nth_list_function_types; try lia.
    rewrite H3. by rewrite Nat2N.id.
  }
  (* from exists statement on *)
  eexists. exists e', fns. split=>//. rewrite -E0.
  split. do 4 f_equal. cbn.
  rewrite <- map_map_seq.
  { clear Hmodule E1.
    rewrite unique_export_names_preserves_functions=>//.
    rewrite gen_fun_instance_simplify_eq; eauto.
    - apply translate_functions_length in HtransFns.
      rewrite -HtransFns. lia.
    - intros. inv HeRestr.
      eapply translate_functions_type_bound; eauto. }
	split; first by rewrite cats0.
  split=>//.
Unshelve. all: by repeat constructor.
Qed. (* TODO: speed up Qed *)

(* helper lemmas for post-instantiation *)

Lemma selem_drop_selem_same : forall sr sr' fr i elem,
  selem sr (f_inst fr) i = Some (Build_eleminst T_funcref elem) ->
  selem_drop sr (f_inst fr) i = Some sr' ->
  selem sr' (f_inst fr) i = Some (Build_eleminst T_funcref [::]).
Proof.
  unfold selem_drop, selem. intros.
  destruct (lookup_N (inst_elems (f_inst fr)) i)=>//.
  destruct (lookup_N (s_elems sr) e) eqn:He=>//.
  injection H as ->. injection H0 as <-. cbn.
  assert (N.to_nat e < length (s_elems sr)). {
    apply nth_error_Some. unfold lookup_N in He. congruence. }
  unfold lookup_N. eapply set_nth_nth_error_same. eassumption.
Qed.

Lemma selem_drop_selem_other : forall sr sr' fr i j elem,
  NoDup fr.(f_inst).(inst_elems) ->
  N.to_nat i <> N.to_nat j ->
  selem sr (f_inst fr) i = Some elem ->
  selem_drop sr (f_inst fr) j = Some sr' ->
  selem sr' (f_inst fr) i = Some elem.
Proof.
  unfold selem_drop, selem. intros.
  destruct (lookup_N (inst_elems (f_inst fr)) i) eqn:Hi=>//.
  destruct (lookup_N (inst_elems (f_inst fr)) j) eqn:Hj=>//.
  destruct (lookup_N (s_elems sr) e) eqn:He=>//. injection H1 as ->.
  destruct (lookup_N (s_elems sr) e0) eqn:He0=>//. injection H2 as <-. cbn.
  unfold lookup_N in *.
  erewrite set_nth_nth_error_other; auto.
  intro. assert (e = e0) as Heq by lia. subst e0.
  eapply NoDup_nth_error in H. apply H0. eassumption.
  apply nth_error_Some; congruence. congruence.
  apply nth_error_Some; congruence.
Qed.

Lemma selem_drop_preserves_stab : forall sr sr' fr i,
  selem_drop sr (f_inst fr) i = Some sr' ->
  stab sr (f_inst fr) 0%N = stab sr' (f_inst fr) 0%N.
Proof.
  unfold selem_drop, stab_elem. intros.
  destruct (lookup_N (inst_elems (f_inst fr)) i)=>//.
  destruct (lookup_N (s_elems sr) e)=>//.
  injection H as <-.
  by destruct (lookup_N (inst_tables (f_inst fr)) 0).
Qed.

Lemma selem_drop_preserves_stab_elem : forall sr sr' fr i j,
  selem_drop sr (f_inst fr) j = Some sr' ->
  stab_elem sr (f_inst fr) 0%N i = stab_elem sr' (f_inst fr) 0%N i.
Proof.
  unfold selem_drop, stab_elem. intros.
  destruct (lookup_N (inst_elems (f_inst fr)) j)=>//.
  destruct (lookup_N (s_elems sr) e)=>//.
  injection H as <-.
  by destruct (lookup_N (inst_tables (f_inst fr)) 0).
Qed.

Lemma selem_drop_preserves_funcs : forall sr sr' fr i,
  selem_drop sr (f_inst fr) i = Some sr' ->
  s_funcs sr = s_funcs sr'.
Proof.
  unfold selem_drop, stab_elem. intros.
  destruct (lookup_N (inst_elems (f_inst fr)) i)=>//.
  destruct (lookup_N (s_elems sr) e)=>//.
  by injection H as <-.
Qed.

Lemma selem_drop_preserves_mems : forall sr sr' fr i,
  selem_drop sr (f_inst fr) i = Some sr' ->
  s_mems sr = s_mems sr'.
Proof.
  unfold selem_drop, stab_elem. intros.
  destruct (lookup_N (inst_elems (f_inst fr)) i)=>//.
  destruct (lookup_N (s_elems sr) e)=>//.
  by injection H as <-.
Qed.

Lemma selem_drop_preserves_globals : forall sr sr' fr i,
  selem_drop sr (f_inst fr) i = Some sr' ->
  s_globals sr = s_globals sr'.
Proof.
  unfold selem_drop, stab_elem. intros.
  destruct (lookup_N (inst_elems (f_inst fr)) i)=>//.
  destruct (lookup_N (s_elems sr) e)=>//.
  by injection H as <-.
Qed.

Lemma stab_update_stab : forall sr sr' fr i v,
  stab_update sr (f_inst fr) 0%N i v = Some sr' ->
  exists tab, stab sr' (f_inst fr) 0%N = Some tab.
Proof.
  unfold stab_update, stab. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0) eqn:Ht=>//.
  destruct (lookup_N (s_tables sr) t) eqn:Ht0=>//.
  destruct ((i <? N.of_nat (tab_size t0))%N) eqn:Hsize=>//.
  injection H as <-. cbn.
  eexists.
  now eapply set_nth_nth_error_same.
Qed.

Lemma stab_update_preserves_tab_size : forall sr sr' fr t t' i v,
  stab sr (f_inst fr) 0%N = Some t ->
  stab sr' (f_inst fr) 0%N = Some t' ->
  stab_update sr (f_inst fr) 0%N i v = Some sr' ->
  tab_size t = tab_size t'.
Proof.
  unfold stab, stab_update, tab_size. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0) eqn:Ht=>//.
  destruct (lookup_N (s_tables sr) t0) eqn:Ht0=>//.
  destruct ((i <? N.of_nat (Datatypes.length (tableinst_elem t1)))%N) eqn:Hsize=>//.
  apply N.ltb_lt in Hsize.
  assert (exists t, nth_error (tableinst_elem t1) (N.to_nat i) = Some t) as [x Hx]. {
    apply notNone_Some. apply nth_error_Some. lia.
  }

  injection H1 as <-. injection H as ->. cbn in *. unfold lookup_N in H0.
  erewrite set_nth_nth_error_same in H0; eauto.
  injection H0 as <-. cbn.
  now erewrite nth_error_set_nth_length.
Qed.

Lemma stab_update_stab_elem_same : forall sr sr' fr i,
  stab_update sr (f_inst fr) 0%N i (VAL_ref_func i) = Some sr' ->
  stab_elem sr' (f_inst fr) 0%N i = Some (VAL_ref_func i).
Proof.
  unfold stab_update, stab_elem. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0) eqn:Ht=>//.
  destruct (lookup_N (s_tables sr) t) eqn:Ht0=>//.
  destruct ((i <? N.of_nat (tab_size t0))%N) eqn:Hsize=>//.
  injection H as <-.
  unfold lookup_N. cbn.
  apply N.ltb_lt in Hsize. destruct t0.
  cbn in Hsize.
  assert (exists x, nth_error tableinst_elem (N.to_nat i) = Some x) as [x Hx].
  { apply notNone_Some, nth_error_Some. lia. }
  erewrite set_nth_nth_error_same; eauto. cbn.
  erewrite set_nth_nth_error_same; eauto.
Qed.

Lemma stab_update_stab_elem_other : forall sr sr' fr i j,
  i <> j ->
  stab_update sr (f_inst fr) 0%N i (VAL_ref_func i) = Some sr' ->
  stab_elem sr (f_inst fr) 0%N j = stab_elem sr' (f_inst fr) 0%N j.
Proof.
  unfold stab_update, stab_elem. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0) eqn:Ht=>//.
  destruct (lookup_N (s_tables sr) t) eqn:Ht0=>//.
  destruct ((i <? N.of_nat (tab_size t0))%N) eqn:Hsize=>//.
  injection H0 as <-. cbn. unfold lookup_N.
  erewrite set_nth_nth_error_same; eauto. cbn.
  erewrite set_nth_nth_error_other; eauto. lia.
  apply N.ltb_lt in Hsize. unfold tab_size in Hsize.
  lia.
Qed.

Lemma stab_update_preserves_tt_elem_type : forall sr sr' fr t t' i f,
  stab sr (f_inst fr) 0%N = Some t ->
  tt_elem_type (tableinst_type t) = T_funcref ->
  stab_update sr (f_inst fr) 0%N i (VAL_ref_func f) = Some sr' ->
  stab sr' (f_inst fr) 0%N = Some t' ->
  tt_elem_type (tableinst_type t') = T_funcref.
Proof.
  unfold stab, stab_update. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0) eqn:Ht=>//.
  destruct (lookup_N (s_tables sr) t0) eqn:Ht0=>//.
  injection H as ->.
  destruct ((i <? N.of_nat (tab_size t))%N) eqn:Hsize=>//.
  injection H1 as <-.
  cbn in H2. unfold lookup_N in H2.
  erewrite set_nth_nth_error_same in H2; eauto.
  now injection H2 as <-.
Qed.

Lemma stab_update_preserves_selem : forall sr sr' fr i v j,
  stab_update sr (f_inst fr) 0%N i v = Some sr' ->
  selem sr (f_inst fr) j = selem sr' (f_inst fr) j.
Proof.
  unfold stab_update. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0)=>//.
  destruct (lookup_N (s_tables sr) t)=>//.
  destruct ((i <? N.of_nat (tab_size t0))%N)=>//.
  by injection H as <-.
Qed.

Lemma stab_update_preserves_funcs : forall sr sr' fr i v,
  stab_update sr (f_inst fr) 0%N i v = Some sr' ->
  s_funcs sr = s_funcs sr'.
Proof.
  unfold stab_update. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0)=>//.
  destruct (lookup_N (s_tables sr) t)=>//.
  destruct ((i <? N.of_nat (tab_size t0))%N)=>//.
  by injection H as <-.
Qed.

Lemma stab_update_preserves_mems : forall sr sr' fr i v,
  stab_update sr (f_inst fr) 0%N i v = Some sr' ->
  s_mems sr = s_mems sr'.
Proof.
  unfold stab_update. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0)=>//.
  destruct (lookup_N (s_tables sr) t)=>//.
  destruct ((i <? N.of_nat (tab_size t0))%N)=>//.
  by injection H as <-.
Qed.

Lemma stab_update_preserves_globals : forall sr sr' fr i v,
  stab_update sr (f_inst fr) 0%N i v = Some sr' ->
  s_globals sr = s_globals sr'.
Proof.
  unfold stab_update. intros.
  destruct (lookup_N (inst_tables (f_inst fr)) 0)=>//.
  destruct (lookup_N (s_tables sr) t)=>//.
  destruct ((i <? N.of_nat (tab_size t0))%N)=>//.
  by injection H as <-.
Qed.

(* strengthened version of post_instantiation_reduce *)
Lemma post_instantiation_reduce_aux : forall num_funs idx hs sr fr t,
  (forall i, i < num_funs + idx ->
     nth_error fr.(f_inst).(inst_elems) i = Some (N.of_nat i)) ->
  length fr.(f_inst).(inst_elems) = num_funs + idx ->
  stab sr fr.(f_inst) 0%N = Some t ->
  t.(tableinst_type).(tt_elem_type) = T_funcref ->
  tab_size t = idx + num_funs ->
  idx + num_funs <= Z.to_nat max_num_functions + num_custom_funs ->
  (* s_elems[i] not yet dropped for i >= idx *)
  (forall i, idx <= N.to_nat i < num_funs + idx ->
     selem sr fr.(f_inst) i = Some (Build_eleminst T_funcref [:: VAL_ref_func i])) ->
  (* s_elems[i] dropped for i < idx *)
  (forall i, N.to_nat i < idx ->
     selem sr fr.(f_inst) i = Some (Build_eleminst T_funcref [::])) ->
  (* tab[i] already initialised for i < idx *)
  (forall i, N.to_nat i < idx ->
     stab_elem sr (f_inst fr) 0%N i = Some (VAL_ref_func i)) ->
  exists sr',
    reduce_trans (hs, sr, fr, [seq AI_basic i | i <- concat
                                 (mapi_aux (idx, [::])
                                   (fun n : nat => get_init_expr_elem n)
                                   (table_element_mapping num_funs idx))])
                 (hs, sr', fr, [::]) /\
  (* table initialised *)
  (forall i, idx <= N.to_nat i < num_funs + idx ->
     stab_elem sr' (f_inst fr) 0%N i = Some (VAL_ref_func i)) /\
  (* previous table entries preserved *)
  (forall i, N.to_nat i < idx ->
     stab_elem sr (f_inst fr) 0%N i = stab_elem sr' (f_inst fr) 0%N i) /\
  (* others preserved *)
  s_funcs sr = s_funcs sr' /\
  s_mems sr = s_mems sr' /\
  s_globals sr = s_globals sr'.
Proof.
  induction num_funs; intros ????? HiE1 HiE2 HsT1 HsT2 Htabsize Hnumfuns HsE1 HsE2 Htab. cbn.
  - exists sr. split. apply rt_refl. split=>//. intros. lia.
  - cbn.
    (* store after tab[i] := i *)
    assert (exists sr', stab_update sr (f_inst fr) 0%N (Wasm_int.N_of_uint i32m (nat_to_i32 idx))
                                   (VAL_ref_func (N.of_nat idx)) = Some sr') as [sr' Hsr']. {
      unfold stab_update. unfold stab in HsT1.
      destruct (lookup_N (inst_tables (f_inst fr)) 0) eqn:Ht=>//.
      destruct (lookup_N (s_tables sr) t0) eqn:Ht0=>//. injection HsT1 as ->.
      assert (HtabSize: (Z.to_N (Wasm_int.Int32.Z_mod_modulus (Z.of_nat idx)) <? N.of_nat (tab_size t))%N).
      apply N.ltb_lt. rewrite Wasm_int.Int32.Z_mod_modulus_id; try lia.
      simpl_modulus. cbn. unfold max_num_functions, num_custom_funs in Hnumfuns. lia.
      rewrite HtabSize. now eexists.
    }

    (* store after elem_drop i *)
    assert (exists sr'', selem_drop sr' (f_inst fr) (N.of_nat idx) = Some sr'') as [sr'' Hsr'']. {
      unfold selem_drop. unfold lookup_N. rewrite HiE1; last lia. do 2 rewrite Nat2N.id.
      assert (Hidx: idx < length (s_elems sr)). {
        have He := HsE1 (N.of_nat idx).
        unfold selem in He. unfold lookup_N in He. rewrite HiE1 in He; last lia.
        do 2 rewrite Nat2N.id in He. apply nth_error_Some. apply notNone_Some.
        eexists. apply He. lia.
      }
      assert (Hlen: length (s_elems sr) = length (s_elems sr')). {
        unfold stab_update in Hsr'. unfold stab in HsT1.
        destruct (lookup_N (inst_tables (f_inst fr)) 0) eqn:Ht=>//.
        destruct (lookup_N (s_tables sr) t0) eqn:Ht0=>//. injection HsT1 as ->.
        cbn in Hsr'.
        destruct (_ <? _)%N=>//. by injection Hsr' as <-.
      }
      rewrite Hlen in Hidx.
      apply nth_error_Some in Hidx.
      apply notNone_Some in Hidx as [x Hx].
      rewrite Hx. now eexists.
    }

    (* prepare IH *)
    assert (HiE1' : forall i : nat, i < num_funs + S idx ->
      nth_error (inst_elems (f_inst fr)) i = Some (N.of_nat i)). {
      intros ? H. replace (num_funs + S idx) with (S num_funs + idx) in H by lia.
      by apply HiE1 in H.
    }
    assert (HsE1' : (forall x : N,
        S idx <= N.to_nat x < num_funs + S idx ->
        selem sr'' (f_inst fr) x = Some {| eleminst_type := T_funcref; eleminst_elem := [:: VAL_ref_func x] |})). {
      intros ? H.
      eapply selem_drop_selem_other; last apply Hsr''. {
        intros. apply NoDup_nth_error.
        intros.
        rewrite HiE1 in H1; try lia.
        assert (j < length (inst_elems (f_inst fr))). { now apply nth_error_Some. }
        rewrite HiE1 in H1. injection H1. lia. lia.
      }
      lia.
      erewrite <- stab_update_preserves_selem; eauto.
      apply HsE1. lia.
    }
    assert (HiE2': Datatypes.length (inst_elems (f_inst fr)) = num_funs + S idx) by lia.
    assert (HsE2' : forall i : N,
      N.to_nat i < S idx ->
      selem sr'' (f_inst fr) i = Some {| eleminst_type := T_funcref; eleminst_elem := [::] |}). {
      intros.
      destruct (Nat.eq_dec idx (N.to_nat i)).
      - (* i = idx *)
        subst.
        rewrite N2Nat.id in Hsr''.
        eapply selem_drop_selem_same; last apply Hsr''.
        erewrite <- stab_update_preserves_selem; eauto.
        apply HsE1. lia.
      - (* i<>idx *)
        eapply selem_drop_selem_other; last apply Hsr''. {
        intros. apply NoDup_nth_error.
        intros.
        rewrite HiE1 in H1; try lia.
        assert (j < length (inst_elems (f_inst fr))). { now apply nth_error_Some. }
        rewrite HiE1 in H1. injection H1. lia. lia.
      }
      lia.
      erewrite <- stab_update_preserves_selem; eauto.
      apply HsE2. lia.
    }

    assert (exists t', stab sr'' fr.(f_inst) 0%N = Some t') as [t' HsT1']. {
      unfold stab_update in Hsr'.
      destruct (lookup_N (inst_tables (f_inst fr)) 0) eqn:Ht=>//.
      destruct (lookup_N (s_tables sr) t0) eqn:Ht0=>//.
      destruct ((Wasm_int.N_of_uint i32m (nat_to_i32 idx) <? N.of_nat (tab_size t1))%N)=>//.
      eexists. erewrite <- selem_drop_preserves_stab; last eassumption.
      injection Hsr' as <-. cbn.
      unfold stab. rewrite Ht. cbn.
      unfold lookup_N.
      erewrite set_nth_nth_error_same; eauto.
    }

    assert (HsT2' : tt_elem_type (tableinst_type t') = T_funcref). {
      erewrite <- selem_drop_preserves_stab in HsT1'; last eassumption.
      have H' := stab_update_preserves_tt_elem_type _ _ _ _ _ _ _ HsT1 HsT2 Hsr' HsT1'.
      assumption.
    }

    assert (HsT3' : tab_size t' = S idx + num_funs). {
      erewrite <- selem_drop_preserves_stab in HsT1'; last eassumption.
      have H' := stab_update_preserves_tab_size _ _ _ _ _ _ _ HsT1 HsT1' Hsr'.
      lia.
    }

    assert (Htab': (forall i : N,
        N.to_nat i < S idx ->
        stab_elem sr'' (f_inst fr) 0%N i = Some (VAL_ref_func i))). {
      intros.
      erewrite <- selem_drop_preserves_stab_elem; eauto.
      replace (Wasm_int.N_of_uint i32m (nat_to_i32 idx)) with (N.of_nat idx) in Hsr'.
      2:{ cbn. unfold max_num_functions, num_custom_funs in Hnumfuns.
          repeat rewrite Wasm_int.Int32.Z_mod_modulus_id; simpl_modulus; cbn; lia. }
      destruct (Nat.eq_dec idx (N.to_nat i)).
      - (* idx = i *)
        subst idx. rewrite N2Nat.id in Hsr'.
        by eapply stab_update_stab_elem_same; eauto.
      - (* idx <> i*)
        erewrite <- stab_update_stab_elem_other; last eassumption; try lia.
        apply Htab; lia.
    }

    have Ht := stab_update_stab _ _ _ _ _ Hsr'. destruct Ht as [tab Ht].
    have HtabsizeEq := stab_update_preserves_tab_size _ _ _ _ _ _ _ HsT1 Ht Hsr'.
    assert (Hnumfuns' : S idx + num_funs <= Z.to_nat max_num_functions + num_custom_funs) by lia.

    have IH := IHnum_funs (S idx) hs sr'' fr t' HiE1' HiE2' HsT1' HsT2' HsT3' Hnumfuns' HsE1' HsE2' Htab'.
    destruct IH as [sr_final [Hred [Htable_final1 [Htable_final2 [Hfuncs [Hmems Hglobals]]]]]].
    unfold max_num_functions in Hnumfuns.

    exists sr_final. cbn. split.
    { (* step through instructions *)
      rewrite (mapi_aux_acc_snoc _ _ []). cbn.
      dostep_nary 3. eapply r_table_init_step; try apply HsE1; cbn; eauto; try lia.
      unfold num_custom_funs in Hnumfuns.
      rewrite Wasm_int.Int32.Z_mod_modulus_id; simpl_modulus; cbn; lia.

      dostep_nary 2. eapply r_table_set_success with (tabv:=VAL_ref_func (N.of_nat idx)). eassumption.
      dostep_nary 3. eapply r_table_init_return; cbn; eauto.
      erewrite <- stab_update_preserves_selem; eauto. apply HsE1. lia. now cbn.
      unfold num_custom_funs in Hnumfuns.
      repeat rewrite Wasm_int.Int32.Z_mod_modulus_id; simpl_modulus; cbn; lia.
      dostep_nary 0. apply r_elem_drop. eassumption. cbn.
      replace (idx + 1) with (S idx) by lia. apply Hred.
    }
    { (* table entries set correctly *)
      split.
      - intros.
        destruct (Nat.eq_dec idx (N.to_nat i)).
        + (* i = idx *)
          subst idx. rewrite -(Htable_final2 i); auto.
        + (* i <> idx *)
          apply Htable_final1. lia.
      - split. intros.
        rewrite -(Htable_final2 i); try lia.
        replace (Wasm_int.N_of_uint i32m (nat_to_i32 idx)) with (N.of_nat idx) in Hsr'.
        2:{ cbn. unfold num_custom_funs in Hnumfuns.
            rewrite Wasm_int.Int32.Z_mod_modulus_id; simpl_modulus; cbn; lia. }
        erewrite (stab_update_stab_elem_other _ _ _ (N.of_nat idx));
          try apply Hsr'; try lia.
        by erewrite selem_drop_preserves_stab_elem; eauto.
        split.
        apply stab_update_preserves_funcs in Hsr'.
        apply selem_drop_preserves_funcs in Hsr''. congruence.
        split.
        apply stab_update_preserves_mems in Hsr'.
        apply selem_drop_preserves_mems in Hsr''. congruence.
        apply stab_update_preserves_globals in Hsr'.
        apply selem_drop_preserves_globals in Hsr''. congruence.
   }
Qed.

(* result about post-instantiation: initialises table with id mapping for i < num_funs *)
Theorem post_instantiation_reduce {fenv} : forall hs sr fr fr' num_funs,
  (forall f f' errMsg, translate_var nenv fenv f errMsg = Ret f' -> N.to_nat f' < num_funs) ->
  INV_instantiation sr fr num_funs ->
  f_inst fr = f_inst fr' ->
  exists sr',
    reduce_trans (hs, sr, fr', [seq AI_basic i | i <- concat
                                 (mapi
                                   (fun n : nat => get_init_expr_elem n)
                                   (table_element_mapping num_funs 0))])
                 (hs, sr', fr', [::]) /\
  INV fenv nenv sr' fr /\
  s_funcs sr = s_funcs sr'.
Proof.
  intros ????? Hfenv Hinv Hfinst.
  unfold INV_instantiation in *.
  destruct Hinv as [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? ?]]]]]]]]]]]]]]]].
  destruct H15 as [HiT HsT].
  destruct H14 as [HsE HiE].

  assert (HiE1': (forall i : nat,
      i < num_funs + 0 -> nth_error (inst_elems (f_inst fr')) i = Some (N.of_nat i))). {
    intros ? Hn. rewrite Nat.add_0_r in Hn. rewrite -Hfinst.
    rewrite HiE. rewrite iota_N_lookup. f_equal. apply /ssrnat.leP. lia. }
  assert (HsE': (forall i : N,
    0 <= N.to_nat i < num_funs + 0 ->
    selem sr (f_inst fr') i = Some {| eleminst_type := T_funcref; eleminst_elem := [:: VAL_ref_func i] |})). {
    intros. rewrite -Hfinst. apply HsE. lia. }

  assert (Hempty1: (forall i : N,
      N.to_nat i < 0 ->
      selem sr (f_inst fr') i = Some {| eleminst_type := T_funcref; eleminst_elem := [::] |})). {
    intros. lia. }
  assert (Hempty2: (forall i : N,
      N.to_nat i < 0 ->
      stab_elem sr (f_inst fr') 0%N i = Some (VAL_ref_func i))). {
    intros. lia. }

  assert (HiE2': Datatypes.length (inst_elems (f_inst fr')) = num_funs + 0). {
    rewrite -Hfinst HiE. rewrite iota_N_length. lia.
  }

  remember ({| tableinst_type := {| tt_limits := {| lim_min := N.of_nat num_funs; lim_max := None |}
                                  ; tt_elem_type := T_funcref
                                  |}
             ; tableinst_elem := repeat (VAL_ref_null T_funcref) num_funs
             |}) as t.
  assert (HsT' : stab sr (f_inst fr') 0%N = Some t). {
    unfold stab. by rewrite HsT -Hfinst HiT. }
  assert (Htabsize: tab_size t = num_funs). { subst t. cbn. by rewrite repeat_length. }
  assert (HTtype : tt_elem_type (tableinst_type t) = T_funcref). { subst t. reflexivity. }

  assert (Hnumfuns: num_funs <= Z.to_nat max_num_functions + num_custom_funs). {
    destruct H8 as [Hbound1 Hbound2].
    rewrite Nat.add_0_r in HiE2'.
    rewrite -HiE2' -Hfinst. lia. }

  rewrite Hfinst in HiT.
  have H' := post_instantiation_reduce_aux num_funs 0 hs sr fr' t HiE1' HiE2' HsT' HTtype Htabsize Hnumfuns HsE'  Hempty1 Hempty2.
  destruct H' as [sr' [Hred [Htab [_ [Hfuncs [Hmems Hglobals]]]]]].
  exists sr'.
  split. apply Hred.
  split=>//.
  (* INV holds now *)
  unfold INV.
  split. (* glob_result writable *)
    intro. intros. destruct (H val) as [s Hs].
    unfold global_var_w, supdate_glob, supdate_glob_s, sglob, sglob_ind in *.
    repeat rewrite Hglobals in Hs.
    destruct (lookup_N (inst_globals (f_inst fr)) glob_result)=>//. cbn. cbn in Hs.
    rewrite <- Hglobals in *.
    destruct (lookup_N (s_globals sr) g)=>//. eexists. reflexivity.
  split. (* glob_out_of_mem writable *)
    intro. intros. destruct (H0 val) as [s Hs].
    unfold global_var_w, supdate_glob, supdate_glob_s, sglob, sglob_ind in *.
    repeat rewrite Hglobals in Hs.
    destruct (lookup_N (inst_globals (f_inst fr)) glob_out_of_mem)=>//. cbn. cbn in Hs.
    rewrite <- Hglobals in *.
    destruct (lookup_N (s_globals sr) g)=>//. eexists. reflexivity.
  split. (* glob_result is 0 *)
  unfold INV_glob_out_of_mem_is_zero, sglob_val, sglob, sglob_ind in *.
    by repeat rewrite <- Hglobals in *.
  split. (* glob_mem_ptr writable *)
    intro. intros. destruct (H2 val) as [s Hs].
    unfold global_var_w, supdate_glob, supdate_glob_s, sglob, sglob_ind in *.
    repeat rewrite Hglobals in Hs.
    destruct (lookup_N (inst_globals (f_inst fr)) glob_mem_ptr)=>//. cbn. cbn in Hs.
    rewrite <- Hglobals in *.
    destruct (lookup_N (s_globals sr) g)=>//. eexists. reflexivity.
  split. (* glob_cap writable *)
    intro. intros. destruct (H3 val) as [s Hs].
    unfold global_var_w, supdate_glob, supdate_glob_s, sglob, sglob_ind in *.
    repeat rewrite Hglobals in Hs.
    destruct (lookup_N (inst_globals (f_inst fr)) glob_cap)=>//. cbn. cbn in Hs.
    rewrite <- Hglobals in *.
    destruct (lookup_N (s_globals sr) g)=>//. eexists. reflexivity.
  split. (* globals all mut i32s *)
    unfold INV_globals_all_mut, globals_all_mut, globals_all_mut32, globals_all_mut64.
    rewrite -Hglobals. assumption.
  split. (* linear memory *)
    unfold INV_linear_memory, smem. by rewrite -Hmems.
  split. (* glob_mem_ptr in linear mem *)
    unfold INV_glob_mem_ptr_in_linear_memory. unfold smem, sglob_val, sglob, sglob_ind.
    rewrite - Hglobals. by rewrite -Hmems.
  split. (* locals all i32s *)
    assumption.
  split. (* num funcs bound *)
    unfold INV_num_functions_bounds. by rewrite -Hfuncs.
  split. (* globals nodup *)
    assumption.
  split. (* table id mapping *)
    unfold INV_table_id. intros ?? Htrans. rewrite Hfinst.
    apply Htab. inv Htrans. apply Hfenv in H14. lia.
  split. (* types *)
    assumption.
  split. (* glob_mem_ptr multiple of 2 *)
    unfold INV_glob_mem_ptr_multiple_of_two, sglob_val, sglob, sglob_ind, smem.
    rewrite -Hglobals. rewrite -Hmems. assumption.
  (* inst funcs id mapping *)
  split.
    unfold INV_inst_funcs_id. rewrite -Hfuncs. assumption.
    unfold INV_i64_glob_tmps_writable.
    intros. intro.
    destruct (H13 gidx H14 val) as [s Hs].
    unfold global_var_w, supdate_glob, supdate_glob_s, sglob, sglob_ind in *. 
    repeat rewrite Hglobals in Hs.
    destruct (lookup_N (inst_globals (f_inst fr)) gidx)=>//. cbn. cbn in Hs.
    rewrite <- Hglobals in *.
    destruct (lookup_N (s_globals sr) g)=>//. eexists. reflexivity.
Qed.


(* instantiation + post-instantiation, refered to as *instantiate* (without apostrophe) in writing *)
Definition instantiate' module hs sr fr :=
  exists sr' fr' es_post,
  instantiate initial_store module [] (sr', fr', es_post) /\
  reduce_trans (hs, sr', fr', map AI_basic es_post) (hs, sr, fr, [::]).

(* instantiation and post-instantiation combined *)
Theorem instantiation_combined_INV_and_more : forall e fds num_funs module fenv main_lenv hs,
  NoDup (collect_function_vars (Efun fds e)) ->
  expression_restricted cenv (Efun fds e) ->
  correct_cenv_of_exp cenv (Efun fds e) ->
  num_funs = numOf_fundefs fds ->
  (Z.of_nat num_funs <= max_num_functions)%Z ->
  LambdaANF_to_Wasm nenv cenv penv (Efun fds e) = Ret (module, fenv, main_lenv) ->

exists sr fr,
  (* instantiate + post-instantiate *)
  instantiate' module hs sr fr /\
  INV fenv nenv sr fr /\

  (* conclusions of module_instantiate_INV_and_more_hold *)

  inst_funcs (f_inst fr) = [:: 0%N & (funcidcs num_funs (N.of_nat num_custom_funs))] /\
  (* value relation holds for all funcs in fds *)
  (forall a , find_def a fds <> None ->
  	exists fidx : funcidx,
	    repr_funvar fenv nenv a fidx /\
	    repr_val_LambdaANF_Wasm cenv fenv nenv penv (Vfun (M.empty _) fds a) sr (f_inst fr) (Val_funidx fidx)) /\

  exists main_fn e' fns,
    main_fn = {| modfunc_type := 0%N (* [] -> [] *)
               ; modfunc_locals := map (fun _ : var => T_num T_i32) (collect_local_variables e)
               ; modfunc_body := e'
               |} /\
    s_funcs sr =
    [:: FC_func_native (Tf [::] [::]) (f_inst fr) main_fn
    &   map (fun f0 : wasm_function =>
             FC_func_native (Tf (repeat (T_num T_i32) (N.to_nat (type f0))) [::]) (f_inst fr)
             {| modfunc_type := type f0; modfunc_locals := locals f0; modfunc_body := body f0 |})
            fns
     ] /\
  (* links e and e' in main_fn above *)
  translate_body nenv cenv (create_local_variable_mapping (collect_local_variables e)) fenv penv e 0 = Ret e' /\
  (* translation of functions *)
  translate_functions nenv cenv fenv penv fds = Ret fns.
Proof.
  intros ??????? Hnodup HeRestr HcenvCorrect Hnumfuns HfnsLength LANF2Wasm.
  (* module instantiates *)
  have HINST := @module_instantiate _ nenv _  _ _ _ _ _ _ _ hs HcenvCorrect Hnodup LANF2Wasm.
  destruct HINST as [sr [fr [es_post Hinst]]].

  assert (HcenvCorrect' : (forall (f : var) (t : fun_tag) (ys : seq var) (e : exp),
             find_def f fds = Some (t, ys, e) ->
             correct_cenv_of_exp cenv e)). {
    intros.
    eapply Forall_constructors_subterm. eassumption.
    apply find_def_dsubterm_fds_e in H.
    apply t_step. apply dsubterm_fds. eassumption. }

  (* INV_instantiate hold after instantiation *)
  have HINST_INV := module_instantiate_INV_and_more_hold _ _ _ _ module fenv main_lenv sr fr es_post Hnodup HeRestr HcenvCorrect' Hnumfuns HfnsLength LANF2Wasm Hinst.
  destruct HINST_INV as [Hinv_inst [HinstFuncs [HvalRel [main_fn [e' [fns' [H_main [Hfuncs [HesPost [He Hfns]]]]]]]]]].

  assert (HfenvBound: (forall (f0 : var) (f' : u32) (errMsg : string),
             translate_var nenv fenv f0 errMsg = Ret f' ->
             N.to_nat f' < num_funs + num_custom_funs)). {
    intros.
    unfold LambdaANF_to_Wasm in LANF2Wasm.
    remember (list_function_types (Z.to_nat max_function_args)) as ftypes.
    destruct (check_restrictions cenv (Efun fds e))=>//.
    destruct (translate_functions _ _ _ _ _) eqn:Hfuns=>//.
    rename l into fns. cbn in LANF2Wasm.
    destruct (translate_body nenv cenv _ _ _) eqn:Hexpr=>//.
    inv LANF2Wasm. rename l into wasm_main_instr.
    unfold create_fname_mapping in H.
    eapply var_mapping_list_lt_length' in H.
    now rewrite collect_function_vars_length in H. }

  (* post-instantiation *)
  have HinstPost := post_instantiation_reduce hs _ _ _ _ HfenvBound Hinv_inst Logic.eq_refl.
  destruct HinstPost as [sr' [HredPost [Hinv HfuncsEq]]].

  exists sr', fr.
  split.
  { unfold instantiate'.
    exists sr, fr, es_post. split. assumption.
    subst.
    apply translate_functions_length in Hfns.
    now rewrite -Hfns. }
  split. assumption.
  split. assumption.
  split.
  { intros ? HfdNone. apply HvalRel in HfdNone.
    destruct HfdNone as [fidx [Hvar Hval]].
    exists fidx. split=>//.
    by apply val_relation_func_depends_on_funcs with (s:=sr). }
  now exists main_fn, e', fns'.
Qed.

End POST_INSTANTIATION.