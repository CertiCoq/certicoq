Require Import SquiggleEq.bin_rels.
Require Import SquiggleEq.eq_rel.
Require Import SquiggleEq.universe.
Require Import SquiggleEq.LibTactics.
Require Import SquiggleEq.tactics.
Require Import Coq.Bool.Bool.
Require Import Coq.Program.Tactics.
Require Import Omega.
Require Import Coq.Program.Basics.
Require Import Coq.Lists.List.
Require Import Coq.Init.Notations.
Require Import SquiggleEq.UsefulTypes.
Require Import Coq.Classes.DecidableClass.
Require Import Coq.Classes.Morphisms.
Require Import SquiggleEq.list.

Require Import Recdef.
Require Import Eqdep_dec.
Require Import SquiggleEq.varInterface.

Generalizable Variable Opid.

Require Import terms.


(* TODO : unbundle *)


(* using dependent types, one can get rid of the incessant use of [option].
However, that would make it almost impossible to write programs over this interface
without using Ltac *)

Record TermAbs (Opid:Type) {gts:GenericTermSig Opid} : Type :=
{
  AbsTerm : Type;
  AbsBTerm : Type;
  absNumBound : AbsBTerm -> nat;

(** If None, then the term was a Var. In this interface, which is intended
to be polymorphic over choice of bindings styles, 
    e.g. named or de-bruijn, concrete or generic,
  there is no way to directly access a Var *)
  absGetOpidBTerms : AbsTerm -> option (Opid * list AbsBTerm);
  
(** A term can be obtained from a bound term iff it binds no variables.
This is just for efficiency. One can already do this by applying a
nil substitution. However, that may unnecessarily involve a traversal *)
  absGetTerm : AbsBTerm -> option AbsTerm;
(*  absGetTermSome: forall b, absNumBound b = 0 <-> isSome (absGetTerm b); *)


(** a limited form of substitution *)
  absApplyBTerm : AbsBTerm -> (list AbsTerm) -> option  AbsTerm;
(*  absApplyBTermSome: forall b l, absNumBound b = length l <-> isSome (absApplyBTerm b l); *)


  absMakeTerm : list AbsBTerm -> Opid -> option AbsTerm;
(*absMakeTermCorr : forall l o,
    map absNumBound l = OpBindings o <-> isSome (absMakeTerm l o);*)

  absMakeBTerm : AbsTerm -> AbsBTerm;
(*absMakeBTermCorr : forall t,
    absNumBound (absMakeBTerm t) = 0; *)


(*absGetOpidBTermsCorr: forall a,
    match absGetOpidBTerms a with
    | Some (o, lb)=> OpBindings o = map absNumBound lb
    | None => True
    end;*)
}.

(*
Can be added to the above, but not needed yet:
(* Because we cannot look inside binders, size is not definable w.r.t the interface *)
  absSizeTerm :  AbsTerm -> nat;
  absSizeBTerm :  AbsBTerm -> nat;

(* size decrease: allows recursion based on size. 
The parametricity plugin seems to fail on Coq's [Function]s.
However, the plugin correctly generated
the abstraction theorem for a proof of the complete natural induction principle 
*)
  sizeDecreasOt : forall a b,
    In b (absGetBTerms a) -> (absSizeBTerm b) < (absSizeTerm a);

  sizeDecreasBt : forall b p,
     (absSizeTerm (absGetTerm b p)) < (absSizeBTerm b);
*)


(* All of above is not specific to Certicoq and should eventually end up
in the SquiggleEq library.*)

Section ParametricityPlugin.
(*
The definitions in this section were automatically generated by the Parametricity plugin 
for Coq 8.6.

Declare ML Module "paramcoq".
Parametricity Recursive TermAbs.
*)

Inductive nat_R : nat -> nat -> Set :=
    nat_R_O_R : nat_R 0 0
  | nat_R_S_R : forall H H0 : nat, nat_R H H0 -> nat_R (S H) (S H0).

Inductive list_R (A₁ A₂ : Type) (A_R : A₁ -> A₂ -> Type)
  : list A₁ -> list A₂ -> Type :=
    list_R_nil_R : list_R A₁ A₂ A_R nil nil
  | list_R_cons_R : forall (H : A₁) (H0 : A₂),
                    A_R H H0 ->
                    forall (H1 : list A₁) (H2 : list A₂),
                    list_R A₁ A₂ A_R H1 H2 ->
                    list_R A₁ A₂ A_R (H :: H1) (H0 :: H2).

Inductive prod_R (A₁ A₂ : Type) (A_R : A₁ -> A₂ -> Type) (B₁ B₂ : Type)
(B_R : B₁ -> B₂ -> Type) : A₁ * B₁ -> A₂ * B₂ -> Type :=
    prod_R_pair_R : forall (H : A₁) (H0 : A₂),
                    A_R H H0 ->
                    forall (H1 : B₁) (H2 : B₂),
                    B_R H1 H2 -> prod_R A₁ A₂ A_R B₁ B₂ B_R (H, H1) (H0, H2).


Inductive option_R (A₁ A₂ : Type) (A_R : A₁ -> A₂ -> Type)
  : option A₁ -> option A₂ -> Type :=
    option_R_Some_R : forall (H : A₁) (H0 : A₂),
                      A_R H H0 -> option_R A₁ A₂ A_R (Some H) (Some H0)
  | option_R_None_R : option_R A₁ A₂ A_R None None.


Inductive GenericTermSig_R (Opid₁ Opid₂ : Type) (Opid_R : Opid₁ -> Opid₂ -> Type)
  : GenericTermSig Opid₁ -> GenericTermSig Opid₂ -> Type :=
    GenericTermSig_R_Build_GenericTermSig_R : forall
                                                (OpBindings₁ : Opid₁ ->
                                                               list nat)
                                                (OpBindings₂ : Opid₂ ->
                                                               list nat),
                                              (forall (H : Opid₁)
                                                 (H0 : Opid₂),
                                               Opid_R H H0 ->
                                               list_R nat nat nat_R
                                                 (OpBindings₁ H)
                                                 (OpBindings₂ H0)) ->
                                              GenericTermSig_R Opid₁ Opid₂
                                                Opid_R
                                                {|
                                                OpBindings := OpBindings₁ |}
                                                {|
                                                OpBindings := OpBindings₂ |}.


Inductive TermAbs_R (Opid₁ Opid₂ : Type) (Opid_R : Opid₁ -> Opid₂ -> Type)
(gts₁ : GenericTermSig Opid₁) (gts₂ : GenericTermSig Opid₂)
(gts_R : GenericTermSig_R Opid₁ Opid₂ Opid_R gts₁ gts₂)
  : TermAbs Opid₁ -> TermAbs Opid₂ -> Type :=
    TermAbs_R_Build_TermAbs_R : forall (AbsTerm₁ AbsTerm₂ : Type)
                                  (AbsTerm_R : AbsTerm₁ -> AbsTerm₂ -> Type)
                                  (AbsBTerm₁ AbsBTerm₂ : Type)
                                  (AbsBTerm_R : AbsBTerm₁ ->
                                                AbsBTerm₂ -> Type)
                                  (absNumBound₁ : AbsBTerm₁ -> nat)
                                  (absNumBound₂ : AbsBTerm₂ -> nat),
                                (forall (H : AbsBTerm₁) (H0 : AbsBTerm₂),
                                 AbsBTerm_R H H0 ->
                                 nat_R (absNumBound₁ H) (absNumBound₂ H0)) ->
                                forall
                                  (absGetOpidBTerms₁ : AbsTerm₁ ->
                                                       option
                                                         (Opid₁ *
                                                          list AbsBTerm₁))
                                  (absGetOpidBTerms₂ : AbsTerm₂ ->
                                                       option
                                                         (Opid₂ *
                                                          list AbsBTerm₂)),
                                (forall (H : AbsTerm₁) (H0 : AbsTerm₂),
                                 AbsTerm_R H H0 ->
                                 option_R (Opid₁ * list AbsBTerm₁)
                                   (Opid₂ * list AbsBTerm₂)
                                   (prod_R Opid₁ Opid₂ Opid_R
                                      (list AbsBTerm₁) (list AbsBTerm₂)
                                      (list_R AbsBTerm₁ AbsBTerm₂ AbsBTerm_R))
                                   (absGetOpidBTerms₁ H)
                                   (absGetOpidBTerms₂ H0)) ->
                                forall
                                  (absGetTerm₁ : AbsBTerm₁ -> option AbsTerm₁)
                                  (absGetTerm₂ : AbsBTerm₂ -> option AbsTerm₂),
                                (forall (H : AbsBTerm₁) (H0 : AbsBTerm₂),
                                 AbsBTerm_R H H0 ->
                                 option_R AbsTerm₁ AbsTerm₂ AbsTerm_R
                                   (absGetTerm₁ H) (absGetTerm₂ H0)) ->
                                forall
                                  (absApplyBTerm₁ : AbsBTerm₁ ->
                                                    list AbsTerm₁ ->
                                                    option AbsTerm₁)
                                  (absApplyBTerm₂ : AbsBTerm₂ ->
                                                    list AbsTerm₂ ->
                                                    option AbsTerm₂),
                                (forall (H : AbsBTerm₁) (H0 : AbsBTerm₂),
                                 AbsBTerm_R H H0 ->
                                 forall (H1 : list AbsTerm₁)
                                   (H2 : list AbsTerm₂),
                                 list_R AbsTerm₁ AbsTerm₂ AbsTerm_R H1 H2 ->
                                 option_R AbsTerm₁ AbsTerm₂ AbsTerm_R
                                   (absApplyBTerm₁ H H1)
                                   (absApplyBTerm₂ H0 H2)) ->
                                forall
                                  (absMakeTerm₁ : list AbsBTerm₁ ->
                                                  Opid₁ -> option AbsTerm₁)
                                  (absMakeTerm₂ : list AbsBTerm₂ ->
                                                  Opid₂ -> option AbsTerm₂),
                                (forall (H : list AbsBTerm₁)
                                   (H0 : list AbsBTerm₂),
                                 list_R AbsBTerm₁ AbsBTerm₂ AbsBTerm_R H H0 ->
                                 forall (H1 : Opid₁) (H2 : Opid₂),
                                 Opid_R H1 H2 ->
                                 option_R AbsTerm₁ AbsTerm₂ AbsTerm_R
                                   (absMakeTerm₁ H H1) (absMakeTerm₂ H0 H2)) ->
                                forall
                                  (absMakeBTerm₁ : AbsTerm₁ -> AbsBTerm₁)
                                  (absMakeBTerm₂ : AbsTerm₂ -> AbsBTerm₂),
                                (forall (H : AbsTerm₁) (H0 : AbsTerm₂),
                                 AbsTerm_R H H0 ->
                                 AbsBTerm_R (absMakeBTerm₁ H)
                                   (absMakeBTerm₂ H0)) ->
                                TermAbs_R Opid₁ Opid₂ Opid_R gts₁ gts₂ gts_R
                                  {|
                                  AbsTerm := AbsTerm₁;
                                  AbsBTerm := AbsBTerm₁;
                                  absNumBound := absNumBound₁;
                                  absGetOpidBTerms := absGetOpidBTerms₁;
                                  absGetTerm := absGetTerm₁;
                                  absApplyBTerm := absApplyBTerm₁;
                                  absMakeTerm := absMakeTerm₁;
                                  absMakeBTerm := absMakeBTerm₁ |}
                                  {|
                                  AbsTerm := AbsTerm₂;
                                  AbsBTerm := AbsBTerm₂;
                                  absNumBound := absNumBound₂;
                                  absGetOpidBTerms := absGetOpidBTerms₂;
                                  absGetTerm := absGetTerm₂;
                                  absApplyBTerm := absApplyBTerm₂;
                                  absMakeTerm := absMakeTerm₂;
                                  absMakeBTerm := absMakeBTerm₂ |}.
End ParametricityPlugin.

Require Import ExtLib.Structures.Monads.
Require Import ExtLib.Data.Monads.OptionMonad.
Require Import Common.ExtLibMisc.
Require Import Common.classes Common.AstCommon.

Instance IndEqDec : Deq (inductive).
Proof using.
  apply @deqAsSumbool.
  exact eq_dec.
Defined.

Import Monad.MonadNotation.
Open Scope monad_scope.
Definition dcon : Set := inductive * N.

Inductive L4Opid : Set :=
 | NLambda
 | NFix (nMut index: nat) 
 | NDCon (dc : dcon) (nargs : nat)
 | NApply
 | NLet
 | NMatch (dconAndNumArgs : list (dcon * nat)).

Definition OpBindingsL4 (nc : L4Opid) : list nat :=
  match nc with
  | NLambda    => [1]
  | NFix nMut _ => repeat nMut nMut
  | NDCon _ nargs    => repeat 0 nargs
  | NApply     => [0,0]
(*  | NProj _ => [0] *)
  | NLet => [0,1]
  | NMatch numargsInBranches => 0::(List.map snd numargsInBranches)
  end.

Instance CoqL4GenericTermSig : GenericTermSig L4Opid:=
{| 
  OpBindings := OpBindingsL4;
|}.


Section Branches.

Context (Opid:Type) {gts:GenericTermSig Opid} {ta : TermAbs Opid}.

(* this definition of branch and find_branch is shared with 
L4a and L5 *)
Definition branch 
  : Type := (dcon * (@AbsBTerm Opid  gts ta))%type.


(** Find a branch in a match expression corresponding to a given constructor
    and arity. *)
Definition find_branch  (d:dcon) (m:nat) (matcht :list branch) : 
    option (AbsBTerm Opid ta) 
  := 
  let obr :=
  find 
    (fun a : (branch) => decide ((d,m) = (fst a, absNumBound _ _ (snd a)))) matcht in
  option_map snd obr.

End Branches.

Section PolyEval.


(** eval_n for L4 (congrete DB), L4a (generic named), and
the (yet to be added) generic (Squiggle-style) DB language between them.
*)
Context (Opid:Type) {gts:GenericTermSig Opid} {Abs4_4a: @TermAbs L4Opid _}.

Local Notation AbsTerm := (AbsTerm _ Abs4_4a).
Local Notation absGetOpidBTerms := (absGetOpidBTerms _ Abs4_4a).
Local Notation absApplyBTerm := (absApplyBTerm _ Abs4_4a).
Local Notation absGetTerm := (absGetTerm _ Abs4_4a).
Local Notation absMakeTerm := (absMakeTerm _ Abs4_4a).
Local Notation absMakeBTerm := (absMakeBTerm _ Abs4_4a).


Typeclasses eauto :=4.

Open Scope program_scope.

(* generalized from L4.expresssion.eval_n *)
Fixpoint eval_n (n:nat) (e:AbsTerm) {struct n} :  option AbsTerm :=
match n with
|0%nat => None
| S n =>  match (absGetOpidBTerms e) with |None => None | Some (o,lbt) =>
  match (o,lbt) with
  (* values *)
  | (NLambda,_)
  | (NFix _ _,_) => Some e

  (* (possibly) non-values *)
  | (NLet, [a;f]) =>
        a <- absGetTerm a;;
        a <- eval_n n a ;;
        s <- (absApplyBTerm f [a]);;
        eval_n n s
  | (NDCon d ne, lb) => 
        vs <- flatten (map (fun b => t <- absGetTerm b ;; eval_n n t)lb) ;;
        (absMakeTerm (map absMakeBTerm vs) o)
  | (NMatch ldn, disc::brs) => 
        disc <- absGetTerm disc;;
        disc <- eval_n n disc;;
        match (absGetOpidBTerms disc) with
        | Some (NDCon d ne, clb) =>
          cvs <- flatten (map absGetTerm clb);;
          b <- find_branch _ d (length cvs) (combine (map fst ldn) brs);;
          s <- (absApplyBTerm b cvs);;
          eval_n n s
        | _ => None
        end
  | (NApply, [f;a]) =>
        a <- absGetTerm a;;
        a <- eval_n n a ;;
        f <- absGetTerm f;;
        f <- eval_n n f;;
        match (absGetOpidBTerms f) with
        | Some (NLambda,[b]) =>
            s <- (absApplyBTerm b [a]);;
            eval_n n s
        | Some (NFix nMut i,lm) =>
            let pinds := List.seq 0 (length lm) in
            let ls := map (fun n => absMakeTerm lm (NFix nMut n)) pinds in
            ls <- flatten ls;;
            im <- select i lm;;
            s <- (absApplyBTerm im ls);;
            s_a_pp <- (absMakeTerm (map absMakeBTerm [s;a]) NApply);;
            eval_n n s_a_pp
        | _ => None
        end
    | _ => None
  end
  end
end.

End PolyEval.
