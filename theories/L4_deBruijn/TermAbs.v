Require Import SquiggleEq.bin_rels.
Require Import SquiggleEq.eq_rel.
Require Import SquiggleEq.universe.
Require Import SquiggleEq.LibTactics.
Require Import SquiggleEq.tactics.
Require Import Coq.Bool.Bool.
Require Import Coq.Program.Tactics.
Require Import Omega.
Require Import Coq.Program.Basics.
Require Import Coq.Lists.List.
Require Import Coq.Init.Notations.
Require Import SquiggleEq.UsefulTypes.
Require Import Coq.Classes.DecidableClass.
Require Import Coq.Classes.Morphisms.
Require Import SquiggleEq.list.

Require Import Recdef.
Require Import Eqdep_dec.
Require Import SquiggleEq.varInterface.

Generalizable Variable Opid.

Require Import terms.
(* This file is not specific to Certicoq and should eventually end up
in the SquiggleEq library.*)

(* TODO : unbundle *)


(* using dependent types, one can get rid of the incessant use of [option].
However, that would make it almost impossible to write programs over this interface
without using Ltac *)

Record TermAbs (Opid:Type) {gts:GenericTermSig Opid} : Type :=
{
  AbsTerm : Type;
  AbsBTerm : Type;
  absNumBound : AbsBTerm -> nat;

(** If None, then the term was a Var. In this interface, which is intended
to be polymorphic over choice of bindings styles, 
    e.g. named or de-bruijn, concrete or generic,
  there is no way to directly access a Var *)
  absGetOpidBTerms : AbsTerm -> option (Opid * list AbsBTerm);
  
(** A term can be obtained from a bound term iff it binds no variables.
This is just for efficiency. One can already do this by applying a
nil substitution. However, that may unnecessarily involve a traversal *)
  absGetTerm : AbsBTerm -> option AbsTerm;
(*  absGetTermSome: forall b, absNumBound b = 0 <-> isSome (absGetTerm b); *)


(** a limited form of substitution *)
  absApplyBTerm : AbsBTerm -> (list AbsTerm) -> option  AbsTerm;
(*  absApplyBTermSome: forall b l, absNumBound b = length l <-> isSome (absApplyBTerm b l); *)


  absMakeTerm : list AbsBTerm -> Opid -> option AbsTerm;
(*absMakeTermCorr : forall l o,
    map absNumBound l = OpBindings o <-> isSome (absMakeTerm l o);*)

  absMakeBTerm : AbsTerm -> AbsBTerm;
(*absMakeBTermCorr : forall t,
    absNumBound (absMakeBTerm t) = 0; *)


(*absGetOpidBTermsCorr: forall a,
    match absGetOpidBTerms a with
    | Some (o, lb)=> OpBindings o = map absNumBound lb
    | None => True
    end;*)
}.

(*
Can be added to the above, but not needed yet:
(* Because we cannot look inside binders, size is not definable w.r.t the interface *)
  absSizeTerm :  AbsTerm -> nat;
  absSizeBTerm :  AbsBTerm -> nat;

(* size decrease: allows recursion based on size. 
The parametricity plugin seems to fail on Coq's [Function]s.
However, the plugin correctly generated
the abstraction theorem for a proof of the complete natural induction principle 
*)
  sizeDecreasOt : forall a b,
    In b (absGetBTerms a) -> (absSizeBTerm b) < (absSizeTerm a);

  sizeDecreasBt : forall b p,
     (absSizeTerm (absGetTerm b p)) < (absSizeBTerm b);
*)

Require Import SquiggleEq.termsDB.

Section SquiggleDBInst.
Context (Name Opid:Type) {gts:GenericTermSig Opid}.

Definition safeGetNT (b:@DBTerm Name Opid) : option (@DTerm Name Opid) :=
match b with
| bterm [] nt => Some nt
| _ => None
end.

Definition applyBTermClosed (b : DBTerm) (l: list DTerm) : option (@DTerm Name Opid) :=
let (n,t):=b in
  if (Z.of_nat (length n) <? (maxFree t))%Z then None
else 
  (if (ZLmax (map maxFree l) (-1) <? 0)%Z then Some (subst_aux_list 0 t l) else None).

Definition mkBTermSafe (lb : list DBTerm) (o: Opid) : option (@DTerm Name Opid) :=
if (decide ((map num_bvars lb) = OpBindings o))%nat then Some (oterm o lb) else None.


Definition TermAbsDB : TermAbs Opid :=
 (@Build_TermAbs _ _ 
  (@DTerm Name Opid) (@DBTerm Name Opid)
   num_bvars
   getOpidBTerms
   safeGetNT
   applyBTermClosed
   mkBTermSafe
   (bterm [])).


End SquiggleDBInst.


Section ParametricityPlugin.
(*
The definitions in this section were automatically generated by the Parametricity plugin 
for Coq 8.6.

Declare ML Module "paramcoq".
Parametricity Recursive TermAbs.
*)

Inductive nat_R : nat -> nat -> Set :=
    nat_R_O_R : nat_R 0 0
  | nat_R_S_R : forall H H0 : nat, nat_R H H0 -> nat_R (S H) (S H0).

Inductive list_R (A₁ A₂ : Type) (A_R : A₁ -> A₂ -> Type)
  : list A₁ -> list A₂ -> Type :=
    list_R_nil_R : list_R A₁ A₂ A_R nil nil
  | list_R_cons_R : forall (H : A₁) (H0 : A₂),
                    A_R H H0 ->
                    forall (H1 : list A₁) (H2 : list A₂),
                    list_R A₁ A₂ A_R H1 H2 ->
                    list_R A₁ A₂ A_R (H :: H1) (H0 :: H2).

Inductive prod_R (A₁ A₂ : Type) (A_R : A₁ -> A₂ -> Type) (B₁ B₂ : Type)
(B_R : B₁ -> B₂ -> Type) : A₁ * B₁ -> A₂ * B₂ -> Type :=
    prod_R_pair_R : forall (H : A₁) (H0 : A₂),
                    A_R H H0 ->
                    forall (H1 : B₁) (H2 : B₂),
                    B_R H1 H2 -> prod_R A₁ A₂ A_R B₁ B₂ B_R (H, H1) (H0, H2).


Inductive option_R (A₁ A₂ : Type) (A_R : A₁ -> A₂ -> Type)
  : option A₁ -> option A₂ -> Type :=
    option_R_Some_R : forall (H : A₁) (H0 : A₂),
                      A_R H H0 -> option_R A₁ A₂ A_R (Some H) (Some H0)
  | option_R_None_R : option_R A₁ A₂ A_R None None.


Inductive GenericTermSig_R (Opid₁ Opid₂ : Type) (Opid_R : Opid₁ -> Opid₂ -> Type)
  : GenericTermSig Opid₁ -> GenericTermSig Opid₂ -> Type :=
    GenericTermSig_R_Build_GenericTermSig_R : forall
                                                (OpBindings₁ : Opid₁ ->
                                                               list nat)
                                                (OpBindings₂ : Opid₂ ->
                                                               list nat),
                                              (forall (H : Opid₁)
                                                 (H0 : Opid₂),
                                               Opid_R H H0 ->
                                               list_R nat nat nat_R
                                                 (OpBindings₁ H)
                                                 (OpBindings₂ H0)) ->
                                              GenericTermSig_R Opid₁ Opid₂
                                                Opid_R
                                                {|
                                                OpBindings := OpBindings₁ |}
                                                {|
                                                OpBindings := OpBindings₂ |}.


Inductive TermAbs_R (Opid₁ Opid₂ : Type) (Opid_R : Opid₁ -> Opid₂ -> Type)
(gts₁ : GenericTermSig Opid₁) (gts₂ : GenericTermSig Opid₂)
(gts_R : GenericTermSig_R Opid₁ Opid₂ Opid_R gts₁ gts₂)
  : TermAbs Opid₁ -> TermAbs Opid₂ -> Type :=
    TermAbs_R_Build_TermAbs_R : forall (AbsTerm₁ AbsTerm₂ : Type)
                                  (AbsTerm_R : AbsTerm₁ -> AbsTerm₂ -> Type)
                                  (AbsBTerm₁ AbsBTerm₂ : Type)
                                  (AbsBTerm_R : AbsBTerm₁ ->
                                                AbsBTerm₂ -> Type)
                                  (absNumBound₁ : AbsBTerm₁ -> nat)
                                  (absNumBound₂ : AbsBTerm₂ -> nat),
                                (forall (H : AbsBTerm₁) (H0 : AbsBTerm₂),
                                 AbsBTerm_R H H0 ->
                                 nat_R (absNumBound₁ H) (absNumBound₂ H0)) ->
                                forall
                                  (absGetOpidBTerms₁ : AbsTerm₁ ->
                                                       option
                                                         (Opid₁ *
                                                          list AbsBTerm₁))
                                  (absGetOpidBTerms₂ : AbsTerm₂ ->
                                                       option
                                                         (Opid₂ *
                                                          list AbsBTerm₂)),
                                (forall (H : AbsTerm₁) (H0 : AbsTerm₂),
                                 AbsTerm_R H H0 ->
                                 option_R (Opid₁ * list AbsBTerm₁)
                                   (Opid₂ * list AbsBTerm₂)
                                   (prod_R Opid₁ Opid₂ Opid_R
                                      (list AbsBTerm₁) (list AbsBTerm₂)
                                      (list_R AbsBTerm₁ AbsBTerm₂ AbsBTerm_R))
                                   (absGetOpidBTerms₁ H)
                                   (absGetOpidBTerms₂ H0)) ->
                                forall
                                  (absGetTerm₁ : AbsBTerm₁ -> option AbsTerm₁)
                                  (absGetTerm₂ : AbsBTerm₂ -> option AbsTerm₂),
                                (forall (H : AbsBTerm₁) (H0 : AbsBTerm₂),
                                 AbsBTerm_R H H0 ->
                                 option_R AbsTerm₁ AbsTerm₂ AbsTerm_R
                                   (absGetTerm₁ H) (absGetTerm₂ H0)) ->
                                forall
                                  (absApplyBTerm₁ : AbsBTerm₁ ->
                                                    list AbsTerm₁ ->
                                                    option AbsTerm₁)
                                  (absApplyBTerm₂ : AbsBTerm₂ ->
                                                    list AbsTerm₂ ->
                                                    option AbsTerm₂),
                                (forall (H : AbsBTerm₁) (H0 : AbsBTerm₂),
                                 AbsBTerm_R H H0 ->
                                 forall (H1 : list AbsTerm₁)
                                   (H2 : list AbsTerm₂),
                                 list_R AbsTerm₁ AbsTerm₂ AbsTerm_R H1 H2 ->
                                 option_R AbsTerm₁ AbsTerm₂ AbsTerm_R
                                   (absApplyBTerm₁ H H1)
                                   (absApplyBTerm₂ H0 H2)) ->
                                forall
                                  (absMakeTerm₁ : list AbsBTerm₁ ->
                                                  Opid₁ -> option AbsTerm₁)
                                  (absMakeTerm₂ : list AbsBTerm₂ ->
                                                  Opid₂ -> option AbsTerm₂),
                                (forall (H : list AbsBTerm₁)
                                   (H0 : list AbsBTerm₂),
                                 list_R AbsBTerm₁ AbsBTerm₂ AbsBTerm_R H H0 ->
                                 forall (H1 : Opid₁) (H2 : Opid₂),
                                 Opid_R H1 H2 ->
                                 option_R AbsTerm₁ AbsTerm₂ AbsTerm_R
                                   (absMakeTerm₁ H H1) (absMakeTerm₂ H0 H2)) ->
                                forall
                                  (absMakeBTerm₁ : AbsTerm₁ -> AbsBTerm₁)
                                  (absMakeBTerm₂ : AbsTerm₂ -> AbsBTerm₂),
                                (forall (H : AbsTerm₁) (H0 : AbsTerm₂),
                                 AbsTerm_R H H0 ->
                                 AbsBTerm_R (absMakeBTerm₁ H)
                                   (absMakeBTerm₂ H0)) ->
                                TermAbs_R Opid₁ Opid₂ Opid_R gts₁ gts₂ gts_R
                                  {|
                                  AbsTerm := AbsTerm₁;
                                  AbsBTerm := AbsBTerm₁;
                                  absNumBound := absNumBound₁;
                                  absGetOpidBTerms := absGetOpidBTerms₁;
                                  absGetTerm := absGetTerm₁;
                                  absApplyBTerm := absApplyBTerm₁;
                                  absMakeTerm := absMakeTerm₁;
                                  absMakeBTerm := absMakeBTerm₁ |}
                                  {|
                                  AbsTerm := AbsTerm₂;
                                  AbsBTerm := AbsBTerm₂;
                                  absNumBound := absNumBound₂;
                                  absGetOpidBTerms := absGetOpidBTerms₂;
                                  absGetTerm := absGetTerm₂;
                                  absApplyBTerm := absApplyBTerm₂;
                                  absMakeTerm := absMakeTerm₂;
                                  absMakeBTerm := absMakeBTerm₂ |}.
End ParametricityPlugin.

